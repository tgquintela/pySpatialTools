

###### 2016-05-28 Aux_featureManagement
#######################################
#
#def create_aggfeatures(discretization, regmetric, features, descriptormodel):
#    """Create aggregated features.
#    """
#    ### 0. Create Aggregator sp_model
#    ## 00. Create map_vals_i and data_input
#    if type(discretization) == tuple:
#        locs, discretizor = discretization
#        regs = discretizor.discretize(locs)
#    else:
#        regs = discretization
#    u_regs = np.unique(regs)
#    u_regs = np.array([u_regs[i] for i in range(len(u_regs))
#                       if u_regs[i] in regmetric.data_input])
#    u_regs = u_regs.reshape((len(u_regs), 1))
#    # Map_vals_i (TODO)
#
#    # Map_output
#    def m_out(neighs_info):
#        outs = np.where(regs == x)[0]
##        if len(outs) == 
#
#    ## 01. Join Retriever with the pieces
#
#    ## 02. Assert and format features retriever
#    # tuple features+pars+descriptormodel
#    # tuple Features+descriptormodel
#    # object Features
#
#    ## 03. Create Sp_descmodel
#
#    ### 1. Compute measure with sp_descmodel
#
#    ### 2. Prepare output (characterizer?)
#    agg = ExplicitFeatures(agg, indices=u_regs, characterizer=characterizer)
#    return agg

#
#def empty_neighs(neighs):
#    logi = False
#    try:
#        logi = not bool(np.prod(np.array(neighs).shape))
#    except:
#        pass
#    return logi


#def compute_featuresnames(descriptormodel, featureobject):
#    """Compute the possible feature names from the pointfeatures."""
#    if type(featureobject) == np.ndarray:
#        featuresnames = descriptormodel._f_default_names(featureobject)
#        return featuresnames
#    if 'typefeat' in dir(featureobject):
#        featuresnames =\
#            descriptormodel._f_default_names(featureobject.features)
#    return featuresnames




###### 2016-05-04 FeatureManager
################################
    def _general_get_typefeats(self, typefeats):
        """Format properly typefeats selector information."""
        if typefeats is None or type(typefeats) != tuple:
            typefeats = (0, 0, 0, 0, 0, 0)
        elif '__len__' not in dir(typefeats):
            typefeats = (0, 0, 0, 0, 0, 0)
        elif len(typefeats) != 6:
            typefeats = (0, 0, 0, 0, 0, 0)
        return typefeats[:2], typefeats[2:4], typefeats[4:]


    def _format_descriptormodel(self, descriptormodel):
        """Formatter of the descriptormodel."""
#        ## Check descriptormodel
#        if descriptormodel is None:
#            raise TypeError("Incorrect descriptormodel type.")
#        ## Outfeatures management
#        out_features = []
#        for i in range(len(self)):
#            out_i = compute_featuresnames(descriptormodel, self.features[i])
#            out_features.append(out_i)
#        logi = all([out == out_features[0] for out in out_features])
#        if logi:
#            self.featuresnames = out_features[0]
#            for i in range(len(self)):
#                self[i].out_features = out_features[0]
#        else:
#            raise Exception("Not the same output features.")
        ## Set descriptormodel
        # Set global information (using first features as default)
#        descriptormodel.set_global_info(self.features[0].features)
        # Link to this class
#        self.descriptormodel = descriptormodel
#        for i in range(len(self)):
#            self.features[i].set_descriptormodel(descriptormodel,
#                                                 self.featuresnames)
        ## Set output
#        self._format_result_building(descriptormodel)

#    def _format_result_building(self, descriptormodel):
#        """Format how to build and aggregate results."""
#        "TODO: Dict-array."
#        "TODO: null_value."
#        ## Size of the possible results.
#        n_vals_i = self._maps_vals_i.n_out
#        n_feats = self.nfeats
#        ## Initialization features
#        if self._out == 'ndarray':
#            null_value = self.features[0]._nullvalue
#            self.initialization_desc =\
#                lambda: np.ones((1, n_feats))*null_value
#        else:
#            # Empty intialization descriptor.
#            # It is composed by free dictionary length
#            self.initialization_desc = lambda: {}
#        ## Global construction of result
#        if n_vals_i is not None and self._out == 'ndarray':
#            shape = (n_vals_i, n_feats, self.k_perturb + 1)
#            ## Init global result
#            self.initialization_output = lambda: np.zeros(shape)
#            ## Adding result (Probably it should be decided flexible)
#            self.add2result = sum_addresult_function
#            self._join_descriptors = lambda x: np.concatenate(x)
#            self.to_complete_measure =\
#                lambda X: descriptormodel.to_complete_measure(X)
#        elif n_vals_i is not None and self._out == 'dict':
#            ## Init global result
#            self.initialization_output =\
#                lambda: [[[] for i in range(n_vals_i)]
#                         for k in range(self.k_perturb+1)]
#            ## Adding result
#            self.add2result = append_addresult_function
#            self._join_descriptors = lambda x: x
#            self.to_complete_measure = sparse_dict_completer
#        else:
#            ## Init global result
#            self.initialization_output =\
#                lambda: [[[], []] for k in range(self.k_perturb+1)]
#            ## Adding result
#            self.add2result = replacelist_addresult_function
#            self._join_descriptors = lambda x: x
#            self.to_complete_measure = sparse_dict_completer_unknown

#            flag = 'sparse_dict_completer' in \
#                str(descriptormodel.to_complete_measure) or \
#                'replacelist_addresult_function' in \
#                str(descriptormodel._defult_add2result)
#            if not flag:
#                ## Init global result
#                self.initialization_output =\
#                    lambda: [[] for k in range(self.k_perturb+1)]
#                ## Adding result
#                self.add2result = append_addresult_function
#            else:
#                ## Init global result
#                self.initialization_output =\
#                    lambda: [[[], []] for k in range(self.k_perturb+1)]
#                ## Adding result
#                self.add2result = replacelist_addresult_function
#
#        self.to_complete_measure =\
#            lambda X: descriptormodel.to_complete_measure(X)

###### 2016-04-07 FeatureObjects
################################
#    def _get_characs_k_array(self, k, idxs, d):
#        """Getting characs with array idxs."""
#        ## Interaction with the features stored
#        feats_k = self._get_feats_k_array(k, idxs)
#        ## Computing characterizers
#        feats_k = self._characterizer(feats_k, d[k])
#        ## Formatting result
#        feats_k = self._format_out(feats_k)
#        return feats_k
#
#    def _get_characs_k_list(self, k, idxs, d):
#        """Interaction with features and computing characs."""
#        n_idxs = len(idxs)
#        k_p, k_i = self._map_perturb(k)
#        feats_k = []
#        ## Not perturbed k
#        if k_p == 0:
#            for i in range(n_idxs):
#                feats_ki = self._virtual_data_array_dict(idxs[i], k)
#                feats_ki = self._characterizer(feats_ki, d[k][i])
#                feats_ki = self._format_out(feats_ki)
#            feats_k.append(feats_ki)
#        ## Virtual perturbed data
#        else:
#            for i in range(n_idxs):
#                feats_ki = self._virtual_data_array_dict(idxs[i], k, k_i, k_p)
#                feats_ki = self._characterizer(feats_ki, d[k][i])
#                feats_ki = self._format_out(feats_ki)
#            feats_k.append(feats_ki)
#        return feats_k
#    def _retrieve_feats_array(self, idxs, c_k, d):
#        """Retrieve and prepare output of the features.
#
#        Parameters
#        ----------
#        idxs: list of list of lists, or 3d np.ndarray
#            Indices we want to get features.
#        c_k: list
#            the different ks we want to get features.
#        d: list of list of lists or None
#            the information of relative position we are going to use in the
#            characterizer.
#
#        TODO
#        ----
#        Use of self.indices
#
#        """
#        ## 0. Variable needed
#        c_k = [c_k] if type(c_k) == int else c_k
#        sh = self.shape[1]
#        ## 2. Compute the whole feats
#        feats = []
#
#
#
#
#        nfeats = self.features.shape[1]
#        sh = idxs.shape
#        feats = []
#        for k in c_k:
#            ## Applying k map for perturbations
#            k_p, k_i = self._map_perturb(k)
#            ## Not perturbed k
#            if k_p == 0:
#                feats_k = self.features[idxs[:, :, k], :, c_k]
#
#
#
#        for i in xrange(len(idxs)):
#            new_idxs = list(np.where(self.indices == idxs[i])[0])
#            if new_idxs != []:
#                feats.append(self.features[new_idxs][:, :, c_k])
#            else:
#                feats.append(np.ones((1, sh, len(c_k))) * self._nullvalue)
#                if self.possible_regions is not None:
#                    if new_idxs[0] not in self.possible_regions:
#                        raise Exception("Incorrect region selected.")
#
#        feats = np.concatenate(feats, axis=0)
#        feats = self._characterizer(feats, d)
#        feats = self._format_out(feats)
#        return feats

    ################################ Candidates ###############################
#    def _real_data_array_array(self, idxs, k, k_i=0, k_p=0):
#        ## TODO: WARNING: Test
#        feats_k = self.features[idxs[:, :, k]]
#        return feats_k

#    def _virtual_data_array_array(self, idxs, k, k_i, k_p):
#        """Virtual data array."""
#        nfeats = self.features.shape[1]
#        sh = idxs.shape
#        idxs_k = idxs[:, :, k].ravel()
#        new_idxs = self._perturbators[k_p].apply2indice(idxs_k, k_i)
#        yes_idxs = np.logical_and(new_idxs >= 0,
#                                  new_idxs < len(self.features))
#        feats_k = np.ones((len(new_idxs), nfeats))*self._nullvalue
#        feats_k[yes_idxs] = self._perturbators[k_p].\
#            apply2features_ind(self.features[:, :, k_i], new_idxs, k_i)
#        #### WARNING: with this reshape
#        feats_k = feats_k.reshape((sh[0], sh[1], feats_k.shape[1]))
#        return feats_k

#    def _real_data_array_list(self, idxs, k, k_i=0, k_p=0):
#        feats_ki = self.features[idxs[k]]
#        return feats_ki

#    def _virtual_data_array_dict(self, idxs, k, k_i, k_p):
#        new_idxs = self._perturbators[k_p].apply2indice(idxs[k], k_i)
#        yes_idxs = [j for j in range(len(new_idxs))
#                    if new_idxs[j] < len(self.features)]
#        feats_ki = np.ones((len(new_idxs), self.features.shape[1]))
#        feats_ki = feats_ki*self._nullvalue
#        feats_ki[yes_idxs] = self._perturbators[k_p].\
#            apply2features_ind(self.features, new_idxs, k_i)
#        return feats_ki

#    def _virtual_data_dict_array(self, idxs, k, k_i, k_p):
#        raise NotImplementedError("Not adapted to non-array element features.")
#
#    def _virtual_data_dict_dict(self, idxs, k, k_i, k_p):
#        raise NotImplementedError("Not adapted to non-array element features.")
#
#    def _real_data_dict_array(self, idxs, k, k_i=0, k_p=0):
#        raise NotImplementedError("Not adapted to non-array element features.")
#
#    def _real_data_dict_dict(self, idxs, k, k_i=0, k_p=0):
#        raise NotImplementedError("Not adapted to non-array element features.")

#    def _get_feats_k_array(self, k, idxs):
#        """Interaction with the stored features."""
#        ## Applying k map for perturbations
#        k_p, k_i = self._map_perturb(k)
#        ## Not perturbed k
#        if k_p == 0:
#            feats_k = self._real_data_array(idxs, k)
#        ## Virtual perturbed data
#        else:
#            feats_k = self._virtual_data_array(idxs, k, k_i, k_p)
#        return feats_k


######## add2result 2016-04-06

def replacelist_addresult_function(x, x_i, vals_i):
    """Replace the element in a preinitialized list.
    * x: [ks][iss_vals]{feats}

    See also:
    ---------
    sparse_dict_completer

    """
    ## Adding to result
    for k in range(len(vals_i)):
        x[k][0].append(x_i[k])
        x[k][1].append(vals_i[k])
    return x


######## Completters 2016-04-06

def sparse_dict_completer(measure, global_info=None):
    """Sparse completer transform the dictionaries into a sparse matrices.

    See also:
    ---------
    replacelist_addresult_function

    """
    ## Completing measure
    for k in range(len(measure)):
        data, iss, jss = [], [], []
        vals_res = np.array(measure[k][1])
        if len(np.unique(vals_res)) == len(vals_res):
            for i in range(len(vals_res)):
                jss += measure[k][0][i].keys()
                data += measure[k][0][i].values()
                iss += len(measure[k][0][i])*[vals_res[i]]
        else:
            for v in np.unique(vals_res):
                idxs = np.where(v == vals_res)[0]
                dicti = {}
                print idxs
                print measure
                for i in idxs:
                    keys = measure[k][0][i].keys()
                    values = measure[k][0][i].values()
                    for j in xrange(len(keys)):
                        try:
                            dicti[keys[j]] += values[j]
                        except:
                            dicti[keys[j]] = values[j]
                    jss += dicti.keys()
                    iss += len(dicti.keys())*[v]
                    data += dicti.values()

        ## Building the matrix and storing it in measure
        shape = (int(np.max(iss))+1, int(np.max(jss))+1)
        data, iss, jss = np.array(data), np.array(iss), np.array(jss)
        measure[k] = coo_matrix((data, (iss, jss)), shape=shape)

    return measure




######## Out formatters 2016-03-31
def count_out_formatter_dict2array(feats, out_features, _out, _nullvalue):
    """Function which contains the out formatting. Has to deal with aggregated
    and point data."""
    feats_o = np.ones((len(feats), len(feats[0]), len(out_features)))
    feats_o = feats_o*_nullvalue
    for k in range(len(feats)):
        for i in range(len(feats[k])):
            feats_o[k, [i], :] =\
                count_out_formatter_dict2array_ind(feats[k][i], out_features,
                                                   _out, _nullvalue)
    return feats_o


def count_out_formatter_dict2array_ind(feats, out_features, _out, _nullvalue):
    feats_o = np.ones(len(out_features))*_nullvalue
    for e in feats:
        feats_o[list(out_features).index(str(e))] = feats[e]
    if len(feats_o.shape) == 1:
        feats_o = feats_o.reshape((1, feats_o.shape[0]))
    return feats_o



######### Characterizers
def characterizer_1sh_counter(pointfeats, point_pos):
    """Characterizer which counts the different types of elements in the
    neighbourhood of the element studied.
    """
    pointfeats_i = np.array(pointfeats[i]).astype(int).ravel()
    sh = pointfeats.shape
    descriptors = [[[]]*sh[2]]*sh[0]
    for p in product(xrange(sh[0]), xrange(sh[2])):
        descriptors[p[0]][p[1]] = dict(Counter(pointfeats_i[p[0], :, p[1]]))
    descriptors = descriptors
    return descriptors

    def _get_characs_k_general(self, k, idxs, d):
        """Genral interaction."""
        if type(idxs) == list:
            feats_k = self._get_characs_k_list(k, idxs, d)
        elif type(idxs) == np.ndarray:
            feats_k = self._get_characs_k_array(k, idxs, d)
        return feats_k

######### Feature Objects 2016-03-30

    def __getitem__(self, key):
        """Possible ways to get items in pst.Features classes:
        * (i, k)
        * (neighs, k)
        * (neighs_info, k)
            where neighs_info is a tuple which could contain (neighs, dists) or
            (neighs,)
        """
        ## 0. Format inputs
        if type(key) == tuple:
            neighs_info = Neighs_Info()
            neighs_info.set_information(self.k_perturb, len(self.features))
            neighs_info.set(key)
            i, d, k, _ = neighs_info.get_information()
#            if type(key[0]) == tuple:
#                neighs_info = Neighs_Info()
#                neighs_info.set_information(self.k_perturb, len(self.features))
#                neighs_info.set(key)
#                i, d, k, _ = neighs_info.get_information()
#            else:
#                i, k = key
#                d = [[[None]]*self.k_perturb+1]*len(i)
        elif type(key) == int:
            kn = self.k_perturb+1
            i, k, d = np.array([[[key]*kn]]), range(kn), [[None]]*kn
        elif type(key) == slice:
            neighs_info = Neighs_Info()
            neighs_info.set_information(self.k_perturb, len(self.features))
            neighs_info.set(key)
            i, d, k, _ = neighs_info.get_information()
        else:
            i, d, k, _ = key.get_information()
        ## 1. Check indices into the bounds (WARNING)
        if type(i) == int:
            if i < 0 or i >= len(self.features):
                raise IndexError("Index out of bounds.")
            i = [i]
        elif type(i) in [np.ndarray, list]:
            if np.min(i) < 0 or np.max(i) >= len(self.features):
                raise IndexError("Indices out of bounds.")
        ## 2. Format k
        if k is None:
            k = list(range(self.k_perturb+1))
        else:
            if type(k) == int:
                k = [k]
            elif type(k) in [np.ndarray, list]:
                k = list(k)
                if np.min(k) < 0 or np.max(k) >= (self.k_perturb+1):
                    msg = "Index of k perturbation is out of bounds."
                    raise IndexError(msg)
        if type(k) != list:
            raise TypeError("Incorrect type of k perturbation index.")
        # Retrive features
        print i, k, d, type(i), type(k)
        feats = self._retrieve_feats(i, k, d)
        return feats

######### Feature Objects 2016-03-09

#    def _retrieve_feats_array_1level(self, idxs, c_k, d):
#        """Retrieve and prepare output of the features.
#
#        Parameters
#        ----------
#        idxs: 3d np.ndarray
#            Indices we want to get features.
#        c_k: list
#            the different ks we want to get features.
#        d: list of list of lists or None
#            the information of relative position we are going to use in the
#            characterizer.
#
#        """
#        feats = []
#        for k in c_k:
#            ## Interaction with the features stored
#            feats_k = self._get_feats_k_array(k, idxs)
#            ## Computing characterizers
#            feats_k = self._characterizer(feats_k, d[k])
#            ## Formatting result
#            feats_k = self._format_out(feats_k)
#            ## Adding to global result
#            feats.append(feats_k)
#        return feats


######### Feature Objects 2016-03-07

    def _features_null_saver(self, idxs, k_p, k_i):
        """"""
        if type(idxs) == slice:
            idxs = list(range(idxs.start, idxs.stop, idxs.step))

        new_indices = self._perturbators[k_p].apply2indice(idxs, k_i)
        idxs_notnull = [i for i in range(len(new_indices))
                        if not new_indices[i] >= len(self.features)]
        new_idxs = [idxs[i] for i in idxs_notnull]
        feats = self._nullvalue*np.ones((len(idxs), self.features.shape[1]))
        return idxs_notnull, new_idxs, feats


    def _retrieve_feats(self, idxs, c_k, d):
        """Retrieve and prepare output of the features."""
        ### idxs as matrix with iss and k shape (TODO)
        #############
        feats = []
        for k in c_k:
            k_p, k_i = self._map_perturb(k)
            if k_p == 0:
                feats_k = self.features[idxs]
            else:
                idxs_notnull, new_idxs, feats_k =\
                    self._features_null_saver(idxs, k_p, k_i)
                feats_k[idxs_notnull] =\
                    self._perturbators[k_p].apply2features_ind(self.features,
                                                               new_idxs, k_i)
            feats_k = self._characterizer(feats_k, d)
            feats_k = self._format_out(feats_k)
            feats.append(feats_k)
        if np.all([type(fea) == np.ndarray for fea in feats]):
            if feats:
                feats = np.concatenate(feats, axis=0)
        return feats

    ## TOMOVE
#    def _get_possible_indices(self, idxs=None):
#        if idxs is None:
#            idxs = slice(0, len(self.features), 1)
#        if isinstance(idxs, slice):
#            start = 0 if idxs.start is None else idxs.start
#            stop = len(self.features) if idxs.stop is None else idxs.stop
#            stop = len(self.features) if idxs.stop > 10**16 else idxs.stop
#            step = 1 if idxs.step is None else idxs.step
#            idxs = slice(start, stop, step)
#        return idxs

#    def _get_possible_indices(self, idxs=None):
#        if idxs is None:
#            idxs = slice(0, len(self.features), 1)
#        if isinstance(idxs, slice):
#            start = 0 if idxs.start is None else idxs.start
#            stop = len(self.features) if idxs.stop is None else idxs.stop
#            stop = len(self.features) if idxs.stop > 10*16 else idxs.stop
#            step = 1 if idxs.step is None else idxs.step
#            idxs = slice(start, stop, step)
#        return idxs


    def __getitem__(self, key):
        """Possible ways to get items in pst.Features classes:
        * (i, k)
        * (neighs, k)
        * (neighs_info, k)
            where neighs_info is a tuple which could contain (neighs, dists) or
            (neighs,)
        """
        print key
        ## 0. Format inputs
        if type(key) == int:
            i, k, d = [key], range(self.k_perturb+1), None
        if type(key) == list:
            i, k, d = key, range(self.k_perturb+1), None
        if type(key) == slice:
            i, k, d = key, range(self.k_perturb+1), None
        if type(key) == tuple:
            assert len(key) == 2
            if type(key[0]) == tuple:
                if len(key[0]) == 2:
                    i, k, d = key[0][0], key[1], key[0][1]
                else:
                    i, k, d = key[0][0], key[1], None
            else:
                if type(key[0]) == int:
                    i = [key[0]]
                    k = key[1]
                else:
                    i = [key[0]] if type(key[0]) == int else key[0]
                    i = list(i) if type(i) == np.ndarray else i
                    assert type(i) in [list, slice]
                    if type(i) == list:
                        n_len_i = len(i)
                    else:
                        i = self._get_possible_indices(i)
                        n_len_i = len(range(i.start, i.stop, i.step))
                    msg = "Ambiguous input in __getitem__ of pst.Features."
                    warnings.warn(msg, SyntaxWarning)
                    if type(key[1]) in [slice, int]:
                        d = None
                        k = [key[1]] if type(key[1]) == int else key[1]
                    else:
                        # Assumption of list or np.ndarray
                        types = [type(j) == int for j in key[1]]
                        if len(key[1]) == n_len_i:
                            d = None
                            if np.all(types):
                                k = list(key[1])
                            else:
                                k = range(self.k_perturb+1)
                                d = [float(j) for j in key[1]]
                        else:
                            msg = "Too ambiguous..."
                            msg += " Dangerous casting to integers is done."
                            warnings.warn(msg, SyntaxWarning)
                            k = [int(j) for j in key[1]]
                            d = None
        # If the input is with neighs_info
        if type(i) == tuple:
            i, d = i
        else:
            d = None
        # Slice input
        if isinstance(i, slice):
            i = self._get_possible_indices(i)
        if isinstance(k, slice):
            start = 0 if k.start is None else k.start
            stop = self.k_perturb+1 if k.stop is None else k.stop
            step = 1 if k.step is None else k.step
            k = range(start, stop, step)
        ## 1. Check indices into the bounds (WARNING)
        if type(i) == int:
            if i < 0 or i >= len(self.features):
                raise IndexError("Index out of bounds.")
            i = [i]
        elif type(i) in [np.ndarray, list]:
            if np.min(i) < 0 or np.max(i) >= len(self.features):
                raise IndexError("Indices out of bounds.")
        elif type(i) == slice:
            i = self._get_possible_indices(i)
            if i.start < 0 or i.stop > len(self.features):
                raise IndexError("Indices out of bounds.")
        ## 2. Format k
        if k is None:
            k = list(range(self.k_perturb+1))
        else:
            if type(k) == int:
                k = [k]
            elif type(k) in [np.ndarray, list]:
                k = list(k)
                if np.min(k) < 0 or np.max(k) >= (self.k_perturb+1):
                    msg = "Index of k perturbation is out of bounds."
                    raise IndexError(msg)
        if type(k) != list:
            raise TypeError("Incorrect type of k perturbation index.")
        # Retrive features
        print i, k, d
        feats = self._retrieve_feats(i, k, d)
        return feats





######### Features retriever 2016-03-07
#    def _get_input_features(self, i, k, typefeats=(0, 0)):
#        """Get 'input' features. Get the features of the elements of which we
#        want to study their neighbourhood.
#        """
#        ## Retrieve features
#        if type(i) == tuple:
#            i_input, k_input = self._maps_input[typefeats[0]](i[0], k)
#            i_input = i_input, i[1]
#        else:
#            i_input, k_input = self._maps_input[typefeats[0]](i, k)
#        feats_i = self.features[typefeats[1]][i_input, k_input]
#        ## Outformat
#        feats_i = self._maps_output(self, feats_i)
#        return feats_i

#    def _get_output_features(self, idxs, k, typefeats=(0, 0)):
#        """Get 'output' features. Get the features of the elements in the
#        neighbourhood of the elements we want to study."""
#        ## Retrieve features
#        if type(idxs) == tuple:
#            idxs_input, k_input = self._maps_input[typefeats[0]](idxs[0], k)
#            idxs_input = idxs_input, idxs[1]
#        else:
#            idxs_input, k_input = self._maps_input[typefeats[0]](idxs, k)
#        if np.any(idxs_input[0]):
#            feats_idxs = self.features[typefeats[1]][idxs_input, k_input]
#        else:
#            feats_idxs = self._join_descriptors([self.initialization_desc()
#                                                 for j in range(len(k_input))])
##            null_value = self.features[typefeats[1]]._nullvalue
##            feats_idxs = np.ones((len(k_input), self.shape[1])) * null_value
#        ## Outformat
#        feats_idxs = self._maps_output(self, feats_idxs)
#        return feats_idxs

########## SpDesc 2016-02-27
#    def _compute_nets(self):
#        """Function used to compute the total measure.
#        """
#        desc = self.featurers.initialization_output()
#        for i in self.iter_indices(self):
#            ## Compute descriptors for i
#            desc_i, vals_i = self._compute_descriptors(i)
#            ## Multiple mappings
#            for k in range(len(vals_i)):
#                desc[vals_i[k], :, k] =\
#                    self.featurers.add2result(desc[vals_i[k], :, k], desc_i[k])
#        desc = self.featurers.to_complete_measure(desc)
#        return desc


## Interpolation_utils 2016-02-24
## Creation function descriptors

##        """
##        Parameters
##        ----------
##        f_weights: function
##            function which eats dists and parameters and returns the weights
##            associated with the related disctances.
##        params_w: dict
##            specific extra parameters of the f_weights
##        f_desc: function
##            function which eats weights, values and parameters and it returns
##            the measure we want to compute.
##        params_d: dict
##            specific extra parameters of the f_desc.
##
##        """
###     feat_arr, f_weights, f_desc, params_d={}, params_w={},
###        mapper_vals_i=None, sp_typemodel='matrix', f_add2retult=None,
###        compute_aggcharacs_i=None, to_complete_measure=None,
###                 name_desc=""):
##        # TODO: Transformation of point_pos?
##        ## Functions to compute descriptors
##        self.f_weights = lambda x: f_weights(x, **params_w)
##        self.f_desc = lambda x, y: f_desc(x, y, **params_d)
##    def compute_predescriptors(self, i, neighs, dists, reindices, k):
##        """
##        """
##        i, neighs = reindices[i, k], reindices[neighs, k]
##        weights = self.f_weights(dists)
##        feat_i, feat_neighs = self.features[neighs], self.features[neighs]
##        characs = self.f_dens(feat_i, feat_neighs, weights, **self.params_d)
##        return characs



##### Descriptormodel 2016-02-24

#    def add2result(self, res_total, res_i):
#        """Addding results to the final aggregated result. We assume here
#        additivity property.
#        TODO: List append possibility
#        """
#        return res_total + res_i


##### FeaturesObjects 2016-02-23

    ########################## Aggregation management #########################
    ###########################################################################
#    def add_aggregation(self, aggfeatures, indices):
#        self.aggfeatures.append(aggfeatures)
#        self.indices.append(indices)

    ########################## Aggregation management #########################
    ###########################################################################
#    def add_aggregations(self, discretization_info, regret, agg_funct):
#        """Create aggregation of fetures to favour the computation."""
#        ## 0. Preparing the inputs
#        if type(discretization_info) == tuple:
#            locs, discretizor = discretization_info
#            regs = discretizor.discretize(locs)
#        else:
#            regs = discretization_info
#        u_regs = np.unique(regs)
#        u_regs = u_regs.reshape((len(u_regs), 1))
#
#        ## 1. Compute aggregation
#        sh = self.shape
#        agg = np.ones((len(u_regs), sh[1], sh[2])) * self._nullvalue
#        for i in xrange(len(u_regs)):
#            neighs_info = regret.retrieve_neighs(u_regs[i])
#            if list(neighs_info[0]) != []:
#                for k in range(self.k_perturb+1):
#                    agg[i, :, k] = agg_funct(self[neighs_info, k],
#                                             neighs_info[1])
#            else:
#                sh = self.shape
#                agg[i, :, :] = np.ones((sh[1], sh[2])) * self._nullvalue
#
#        ## 2. Prepare output
#        agg = AggFeatures(agg, indices=u_regs,
#                          characterizer=self._characterizer)
#
#        return agg




#### Feature retriever  2016-02-02

class DummyReindiceMapper:
    "Dummy mapper."
    reindices = None

    def __init__(self, reindices=None):
        self.reindices = reindices

    def __getitem__(self, key):
        i, k = key
        if self.reindices is None:
            return i
        else:
            return self.reindices[i, k]

#### Descriptormodel  2016-01-28

#    def compute_aggdescriptors(self, discretizor, regionretriever, locs):
#        """Compute aggregate region desctiptors for each region in order to
#        save computational power or to ease some computations.
#        WARNING: This function calls to compute_aggcharacs_i, which is not
#        required to be in the descriptor models object methods (there are some
#        of them which they cannot be descomposed in that way).
#
#        discretizor: Discretization object or numpy.ndarray
#            the discretization information of the location elements. It is
#            the object or the numpy.ndarray that will map an element id to
#            a collected elements or regions.
#        regionretriever: relative_pos object
#            region retriever which is able to retrieve neighbours regions from
#            a retriever type and a relation of regions object.
#        locs: numpy.ndarray
#            the location of the elements in the space.
#
#        Parameters
#        ----------
#        aggcharacs: numpy.ndarray
#            the aggcharacs for each region or collection of elements.
#
#        """
#        if type(discretizor) == np.ndarray:
#            discretized = discretizor
#        else:
#            discretized = discretizor.discretize(locs)
#            discretized = discretized.reshape((discretized.shape[0], 1))
#        u_regs = np.unique(discretized)
#        null_values = self.initialization_desc()
#        aggcharacs = np.vstack([null_values for i in xrange(u_regs.shape[0])])
#        for i in xrange(u_regs.shape[0]):
#            reg = u_regs[i]
#            neighs, dists = regionretriever.retrieve_neighs(np.array([reg]))
#            neighs_i, dists_i = get_individuals(neighs, dists, discretized)
#            #locs_i = locs[list(neighs_i), :]
#            ## Que hacer con locs i?
#            if len(neighs_i) != 0:
#                aggcharacs[i, :] = self.compute_aggcharacs_i(neighs_i, dists_i)
#        return aggcharacs, u_regs, null_values

#    def compute_descriptors(self, i, predescriptors):
#        """Function to made last corrections for the descriptors computed
#        initially using neighbourhood information, by using a global
#        information.
#        """
#        return predescriptors

#    def generate_aggregation(self, retrievers):
#        "Probably in spatial descriptors models."
#        n = len(retrievers)
#        aggdescriptors = [None]*n
#        for i in range(n):
#            if retrievers[i].typeret == 'region':
#                aggdescriptors[i] = self.compute_aggdescriptor(retrievers[i])
#        return aggdescriptors

#    def retrieve_aggregation(self, agg_arr, feat_arr, reindices):
#        ## n_uuu is given by n_dim object parameter
#        u_v, uuu = np.unique(agg_arr), np.unique(feat_arr)
#        n_u, n_uuu, n_rein = u_v.shape[0], uuu.shape[0], reindices.shape[1]
#        res = np.zeros((n_u, n_uuu, n_rein)).astype(int)
#        for j in range(reindices.shape[1]):
#            for i in xrange(u_v.shape[0]):
#                logi = agg_arr == u_v[i]
#                logi = logi[reindices[:, j]]
#                feats = feat_arr[logi, :]
#                precharacs = self.compute_characs_i(feats)  # characs
#                #c = dict(Counter(feats[:, 0]))
#                #res[i, c.keys(), j] += np.array(c.values())
#                res[i, :, j] += characs

#    def compute_general_predescriptors(self, ):
#        pass

#    def compute_partial_descriptors(self, i, neighs_info, k, typefeats):
#        desc_i, desc_neighs = self._get_point_features(i, neighs_info, k,
#                                                       typefeats)
#        descriptors = self._compute_descriptors_spec(i, neighs, desc_i,
#                                                     desc_neigh)
#        return descriptors


#### Feature retriever (point retriever) 2016-01-27

#    def _format_reindices(self, reindices):
#        "Format reindices."
#        if reindices is None:
#            self._reindices = DummyReindiceMapper()
#            self._k_reindices = 1
#        else:
#            if type(reindices) == np.ndarray:
#                if len(reindices.shape) == 1:
#                    reindices = reindices.reshape((reindices.shape[0], 1))
#                self._reindices = reindices
#                self._k_reindices = reindices.shape[1]
#            else:
#                try:
#                    reindices[0, 0]
#                    self._reindices = reindices
#                except:
#                    raise Exception("Incorrect reindices.")

#### Spatial dzescriptor models 2016-01-26

#
#def format_inputs_sp_descriptor(descriptormodel, retrievers, aggdescriptor):
#    """Formatting function.
#    """
#    if type(retrievers) != list:
#        retrievers = [retrievers]
#    #aggdescriptor = descriptormodel.generate_aggregation(retrievers)
#    return descriptormodel, retrievers, aggdescriptor


#    def compute_descriptors(self, i):
#        """
#        Dictionary
#        ----------
#        typeret: integer type of return. Index of Retrievers
#        neighs: neighs retrieved by the retriever number typeret
#        characs: using all the information of the point and its neighbourhood.
#
#        """
#        ## Retrieve type retriever
#        typeret = self.get_typeret(i)
#        ## Division of point or region retriever
#        neighs_info = self.retriever.retrieve_neighs(i, typeret=typeret)
#        characs, vals_i = self.descriptormodel.compute_descriptors(i,
#                                                                   neighs_info,
#                                                                   typeret)
#        return characs, vals_i


#
#    def compute_descriptors(self, i, k):
#        """
#        Dictionary
#        ----------
#        typeret: integer type of return. Index of Retrievers
#        neighs: neighs retrieved by the retriever number typeret
#        characs: using all the information of the point and its neighbourhood.
#
#        """
#        ## Retrieve type retriever
#        typeret, typefeats = self._get_methods(i)
#
#        ## Division of point or region retriever
#        if self.retrievers[typeret].typeret == 'point':
#            ## Retrieve
#            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
#            ## Compute characs
#            characs =\
#                self.descriptormodel.compute_predescriptors(i, neighs, dists,
#                                                            self.reindices, k)
#        else:
#            ## Retrieve
#            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
#            neighs_r, dists_r = self.retrievers[typeret].retrieve_neighs(i)
#            ## Compute characs
#            characs =\
#                self.aggdescriptor[typeret].compute_characs(i, neighs, dists,
#                                                            neighs_r, dists_r,
#                                                            k, self.reindices)
#        ## Compute descriptors
#        descriptors = self.descriptormodel.compute_descriptors(i, characs)
#        return descriptors
#
#    def compute_net(self):
#        """Function used to compute the total measure.
#        """
#        n_calc = self.reindices.shape[1]
#        corr = self.descriptormodel.initialization_output(n_calc)
#        for i in xrange(self.descriptormodel.features.shape[0]):
#            for k in range(n_calc):
#                # 1. Retrieve local characterizers
#                val_i = self.descriptormodel.compute_value_i(i, k,
#                                                             self.reindices)
#                corr_i = self.compute_descriptors(i, k)
#                # 3. Aggregation
#                ## TODO: indexing result
#                corr[val_i, :, k] =\
#                    self.descriptormodel.add2result(corr[val_i, :, k], corr_i)
#        corr = self.descriptormodel.to_complete_measure(corr)
#        return corr

"""
initialization_output
compute_descriptors
to_complete_measure
add2result
"""

"""
#aggdescriptors: list (discretization) [typeret]


    def compute_descriptors(self, i):
        ""
#        Dictionary
#        ----------
#        typeret : integer type of return. Index of Retrievers
#        neighs : neighs retrieved by the retriever number typeret
#        characs : using all the information of the point and its neighbourhood.
        ## Retrieve type retriever
        typeret, typefeats = self._get_methods(i)

        ## Model0
        for k in range(k_rein):
            i_k
            neighs_info = self.retrievers.retrieve_neighs(i_k,
                                                          typeret_i=typeret)
            characs, vals_i =\
                self.descriptormodel.compute_predescriptors(i, neighs_info, k)



    def compute_descriptors(self, i, k):
        ## Retrieve type retriever
        typeret = self.get_typeret(i)

        ## Division of point or region retriever
        if self.retrievers[typeret].typeret == 'point':
            ## Retrieve
            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
            ## Compute characs
            characs =\
                self.descriptormodel.compute_predescriptors(i, neighs, dists,
                                                            self.reindices, k)
        else:
            ## Retrieve
            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
            neighs_r, dists_r = self.retrievers[typeret].retrieve_neighs(i)
            ## Compute characs
            characs =\
                self.aggdescriptor[typeret].compute_characs(i, neighs, dists,
                                                            neighs_r, dists_r,
                                                            k, self.reindices)
        ## Compute descriptors
        descriptors = self.descriptormodel.compute_descriptors(i, characs)
        return descriptors


    def compute_descriptors(self, i):

        characs_i, idxs_i = [], []
        neighs, dists = retrievers.retrieve_neighs(i, typeret=typeret)
        for k in range(self.reindices.shape[1]):
            i_rei, neighs_rei
            i_disc_rei, neighs_rei
            aggdesc = None
            if aggdescriptors[typeret] is not None:
                aggdesc = aggdescriptors[typeret][k]
            characs =\
                self.descriptormodel.compute_general_predescriptors(i_disc_rei,
                                                                    neighs,
                                                                    dists)


        ## Retrieve neighsbours
        neighs_rei, dists = self.retriever.g_retrieve_neighs(i_rei, typeret, k,
                                                             self.reindices)
        i_rei = self.reindices[i, k]

        ## Compute discretization
        i_disc_rei, neighs_rei = self.retriever.g_discretization(i_rei,
                                                                 neighs_rei, k,
                                                                 self.reindices)
        ## Compute general predescriptors
        characs = self.descriptormodel.compute_general_predescriptors(i_disc,
                                                                      neighs,
                                                                      dists)

        ## Compute descritptors
        descriptors = self.descriptormodel.compute_descriptors(i_rei, characs,
                                                               typeret)
        return descriptors


        ## Reserve memory for each one
        #characs(k_rein, characs_size)
        characs_i, idxs_i = [], []
        k_rein = range(self.reindices.shape[1]) if k_rein is None else k_rein
        ## Retrieve neighbours
        neighs, dists = self.retriever.g_retrieve_neighs(i, typeret)
        for k in k_rein:
            ## Compute reindices
            i_rei, neighs_rei
            ## Compute discretization
            i_disc_r
            ##
            characs_i.append()
            idxs_i.append()


    def compute_net(self):
        n_calc = self.reindices.shape[1]
        corr = self.descriptormodel.initialization_output(n_calc)
        k_rein = range(n_calc)
        for i in xrange(self.descriptormodel.features.shape[0]):
            # 1. Retrieve local descriptors
            characs_i, idxs_i = self.compute_descriptors(i, k_rein)
            for k in k_rein:
                # 3. Aggregation
                corr[idxs_i[k]] =\
                    self.descriptormodel.add2result(corr[idxs_i[k]],
                                                    characs_i[k])
        corr = self.descriptormodel.to_complete_measure(corr)
        return corr


        ## Division of point or region retriever
        if self.retrievers[typeret].typeret == 'point':
            ## Retrieve
            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
            ## Compute characs
            characs =\
                self.descriptormodel.compute_predescriptors(i, neighs, dists,
                                                            self.reindices, k)
        else:
            ## Retrieve
            neighs, dists = self.retrievers[typeret].retrieve_neighs(i)
            neighs_r, dists_r = self.retrievers[typeret].retrieve_neighs(i)
            ## Compute characs
            characs =\
                self.aggdescriptor[typeret].compute_characs(i, neighs, dists,
                                                            neighs_r, dists_r,
                                                            k, self.reindices)


"""



#### Spatial dzescriptor models 2016-01-14

## TOMOVE: to retrievers
#    def compute_neighbourhoodnet(self, typeoutput):
#        """TODO: General function."""
#        N_t = self.retriever.data.shape[0]
#        lista = []
#        for i in xrange(N_t):
#            neighs, dists = self.retrieve_neighs_spec(i, ifdistance=True)
#            if not self.flag_auto:
#                neighs, dists = filter_possible(i, neighs, dists)
#            n_neigh = len(list(neighs))
#            aux = [(i, neighs[j], dists[j]) for j in range(n_neigh)]
#            lista.append(aux)
#        ## Transformation to a sparse matrix
#        neighnet = sparse_from_listaregneighs(lista, range(N_t), symmetric)
#        if typeoutput == 'network':
#            neighnet = nx.from_scipy_sparse_matrix(neighnet)
#        if typeoutput == 'matrix':
#            neighnet = neighnet.A
#        return neighnet


#    def to_complete_measure(self, corr_loc):
#        'TODO: aggdescriptor'
#        if self.aggdescriptor is None:
#            corr_loc = self.descriptormodel.to_complete_measure(corr_loc)
#        else:
#            corr_loc = self.aggdescriptor.to_complete_measure(corr_loc)
#        return corr_loc


#### Descriptor models Process 2016-01-14

    def compute_aggdescriptors(self, descriptor, feat_arr, reindices):
        "TODO"
        ## General variables needed
        n = self.retriever.data.shape[0]
        aggdesctriptors, aggregions, null_values = [], [], []
        ## Computation aggdescriptors
        for z in range(len(self.retriever.discretizors)):
            u_regions = np.unique(self.locs_r[z])
            aggdescriptor = np.zeros(())
            # aggdescriptor = descriptor.inizialize_result
            for i in xrange(n):
                neighs, dists = self.retrieve_neigh_i(i, info_i=z)
                characs_i = descriptor.compute_characs(feat_arr[neighs], dists)
                # Add to aggdescriptor

            ## Add to aggregates
            aggdesctriptors.append(aggdescriptor)
            aggregions.append(u_regions)
            null_values.append()
        return aggdesctriptors, aggregions, null_values






#### Descriptor models Process 2016-01-10
class ModelProcess(Processer):
    """Class which performs the spatialmodel computation. This process assigns
    a descriptors for each point in the dataset regarding their raw features
    and the spatial relation between them.

    ===============================
    Functionalities:
    - Compute net from data (parallel/sequential)
    - Compute matrix for trainning approach (parallel/sequential)

    ================================
    Problems:

    ================================
    TODO:

    """

    ### Class parameters
    ## Process descriptors
    time_expended = 0.  # Time expended along the process
    n_procs = 0  # Number of cpu used in parallelization (0 no parallel)
    proc_name = ""  # Name of the process
    proc_desc = ""
    ## Logger info
    lim_rows = 0  # Lim of rows done in a bunch. For matrix comp or information
    logfile = None  # Log file
    ## Bool options
    bool_inform = False  # Give information of the process
    bool_matrix = False  # compute matrix

    subproc_desc = []
    t_expended_subproc = []




#### Descriptor models Process 2016-01-10
    def compute_measure_all(self, df, reindices=None):
        """Main function for building the index of the selected model. This
        function acts as swicher between the different possibilities:
        - Parallel from data/neighs/(agg/preagg)
        - Sequential from data/neighs/(agg/preagg)
        """

        ## 0. Setting needed variables (TODO: cambiar)
        m_aux0 = "training matrix" if self.bool_matrix else "net"
        name_desc = self.descriptormodel.name_desc
        self.proc_desc = self.proc_desc % (m_aux0, name_desc)
        t00 = self.setting_global_process()

        # Preparing needed vars
        locs, feat_arr, info_ret, cond_agg = split_df(df, self.typevars)
        reindices = compute_reindices(df, reindices)
        self.sp_descriptormodel.setmodel(feat_arr, info_ret, cond_agg)
        # clean unnecessary
        del df, info_ret, cond_agg

        ## 1. Computation of the measure (parallel if)
        corr_loc = self.compute_mea_sequ_generic(locs, feat_arr, reindices)

        ## 2. Building a net
        corr_loc = self.descriptormodel.to_complete_measure(corr_loc)
        ## Closing process
        self.close_process(t00)
        return corr_loc

    def compute_mea_sequ_generic(self, locs, feat_arr, reindices):
        """Main function to perform spatial correlation computation in a
        sequential mode using aggregated information given by a '''''file'''''.
        """

        ## 0. Intialization of needed variables
        N_t = locs.shape[0]
        n_vals0, n_vals1 = self.sp_descriptormodel.model_dim
        n_calc = reindices.shape[1]  # TODO: reindices always 2 dim
        corr_loc = np.zeros((n_vals0, n_vals1, n_calc))

        ## 1. Computation of local spatial correlations
        ## Begin to track the process
        t0, bun = self.setting_loop(N_t)
        for i in xrange(N_t):
            ## Obtaining neighs of a given point
            #point_i = locs[i, :].reshape(1, locs.shape[1])
            ## Loop over the possible reindices
            for k in range(n_calc):
                # 1. Retrieve local characterizers
                val_i = self.sp_descriptormodel.get_value_i(i, k)
                chars = self.sp_descriptormodel.get_characterizers(i, k)
                #### (compute them or retrieve precomputed)
#                val_i, chars =\
#                    self.sp_descriptormodel.get_characterizers(i, k, feat_arr,
#                                                               point_i,
#                                                               reindices)
                # 2. Computation of the local measure
                corr_loc_i =\
                    self.sp_descriptormodel.compute_descriptors(val_i, chars)
                # 3. Aggregation
                corr_loc[val_i, :, k] =\
                    self.sp_descriptormodel.adding(corr_loc[val_i, :, k],
                                                   corr_loc_i)
            ## Finish to track this process
            t0, bun = self.messaging_loop(i, t0, bun)
        return corr_loc

##########################################################
#### Descriptor models 2016-01-10


    def get_neighbourhood_info(self, i, typeret):
        "Getting neighbourhood information."
        if typeret != 0:
            neighs, dists = self.aggretriever[typeret].retrieve_neigh(i)
        else:
            neighs, dists = self.aggretriever[typeret].retrieve_neigh(i)
        return neighs, dists

    def get_characs_i_neighs(self, i, neighs, k, typeret):
        'TODO: aggregate not precomputed'
        if typeret != 0:
            disc_i = self.retriever[typeret].discretize(i)
            chars_i = self.feats_agg[typeret].get_aggcharacs(disc_i, k)
            chars_neigh = self.feats_agg[typeret].get_aggcharacs(neighs, k)
        else:
            chars_i = self.feats_arr[[self.reindices[i, k]], :]
            chars_neigh = self.feats_arr[[self.reindices[neighs, k]], :]
        return chars_i, chars_neigh

    def compute_characs(self, feats_i, chars_i, chars_neigh, dists, typeret):
        'TODO: descriptormodel function compute_characs'
        characs = self.descriptormodel.compute_characs(feats_i, chars_i,
                                                       chars_neigh, dists)
        return characs

    def get_characterizers(self, i, k):
        """
        Dictionary
        ----------
        typeret: integer type of return. Index of Retrievers
        disc_i: formatted i
        neighs: neighs retrieved by the retriever number typeret
        chars_i: characterizers defined using feats of i
        chars_neigh: characterizers which define neigh using only feats.
        characs: using all the information of the point and its neighbourhood.
        """
        ## Retrieve type retriever
        typeret = self.cond_agg[i]
        ## Retrieve
        neighs, dists = self.get_neighbourhood_info(i, typeret)
        chars_i, chars_neigh = self.get_characs_i_neighs(i, neighs, k, typeret)
        characs = self.compute_characs(chars_i, chars_neigh, dists, typeret)
        return characs



#### Descriptor models 2016-01-04

#    def get_characterizers(self, i, reindice):
#        '''Get characterizers knowing the i array and the reindices.'''
#        ## Retrieve neighbourhood information
#        typeret = self.cond_agg[i]
#
#        neighs, dists = self.retriever.retrieve_neigh(i, typeret)
#        ## Compute characs
#        characs = self.compute_characs(i, neighs, dists, reindice, typeret)
#        ## Retrieve characterizers from neighbourhood information
#        val_i = self.descriptormodel.compute_value_i(i, reindice)
#        return val_i, characs

#    def compute_characs(self, i, neighs, dists, reindice, typeret):
#        ## We have to use descriptor and retriever. Depends on precomputed.
#        if self.precomputed:
#            self.retriever
#            i_disc = self.retriever.discretized_i(i)  # TODO
#            characs = self.feats_agg[typeret][i_disc, :, k]
#            ### ??? dists?
#        else:
#            pass
#        ## Deal with reindices
#        pass



#### Descriptor models 2016-01-03

#    def get_neighbourhood_info(self, i, typeret):
#        "Getting neighbourhood information."
#        if typeret != 0:
#            disc_i = self.retriever[typeret].discretize(i)
#            neighs, dists = self.retriever[typeret].retrieve_neigh(disc_i)
#        else:
#            neighs, dists = self.retriever[typeret].retrieve_neigh(i)
#        return neighs, dists
#
#    def get_characs_i_neighs(self, i, neighs, k, typeret):
#        'TODO: aggregate not precomputed'
#        if typeret != 0:
#            disc_i = self.retriever[typeret].discretize(i)
#            chars_i = self.feats_agg[typeret][disc_i, :, k]
#            chars_neigh = self.feats_agg[typeret][neighs, :, k]
#        else:
#            chars_i = self.feats_arr[[self.reindices[i, k]], :]
#            chars_neigh = self.feats_arr[[self.reindices[neighs, k]], :]
#        ## Retrieve in proper format
#        chars_i = ensure_2dim(chars_i, sh_known=(1, None))
#        chars_neigh = ensure_2dim(chars_neigh, sh_known=(len(neighs), None))
#        return chars_i, chars_neigh