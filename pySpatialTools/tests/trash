
### 2016-04-19 spatial_discretizer
#
#    # Discretization action
#    regions = disc1.discretize(locs1)
#    regions = disc1.discretize(locs2)
#    regions = disc2.discretize(locs1)
#    regions = disc2.discretize(locs2)
#    regions = disc6.discretize(locs1)
#    regions = disc6.discretize(locs2)
#    regions = disc4.discretize(locs1)
#    regions = disc4.discretize(locs2)
#    regions = disc5.discretize(locs1)
#    regions = disc5.discretize(locs2)
#    regions = disc6.discretize(elements1)
#    regions7 = disc7.discretize(elements2)
#
#    a = randint_sparse_matrix(0.2, (2000, 100), 1)
#
#    # Inverse discretization action
#
#    # Contiguity
#    contiguity = disc1.get_contiguity()
#    contiguity = disc2.get_contiguity()
#    #contiguity = disc6.get_contiguity()
#    #contiguity = disc4.get_contiguity()
#    #contiguity = disc5.get_contiguity()
#    #contiguity = disc6.get_contiguity()
#    #contiguity = disc7.get_contiguity()
#
#    ## Other parameters and functions
#    disc1.borders, disc5.borders, disc6.borders
#
#    ## Extending coverage
#    n_in, n_out = 100, 20
#    relations = [np.unique(np.random.randint(0, n_out,
#                                             np.random.randint(n_out)))
#                 for i in range(n_in)]
#
#    disc8 = SetDiscretization(relations)
#    relations = [list(e) for e in relations]
#    disc9 = SetDiscretization(relations)
#    disc8.discretize(np.random.randint(0, 20, 100))
#    disc9.discretize(np.random.randint(0, 20, 100))
#
#    ## Check regions
#    neighs = disc1.check_neighbors(np.array([0, 1]), 0)
#
#    activated = disc1.get_activated_regions(locs1[:10])
#    activated = disc2.get_activated_regions(locs1[:10])
#    activated = disc6.get_activated_regions(locs1[:10])
#    activated = disc4.get_activated_regions(locs1[:10])
#    activated = disc5.get_activated_regions(locs1[:10])
#    activated = disc6.get_activated_regions(elements1[:10])
#    activated = disc7.get_activated_regions(elements2[:10])
#    activated = disc8.get_activated_regions(np.array([0, 1]))
#    activated = disc9.get_activated_regions(np.array([0, 1]))
#
#    disc1.belong_region(locs1[0], 0)
#    disc2.belong_region(locs1[1], 0)
#    limits = disc1.get_limits()
#    limits = disc1.get_limits(0)
#    limits = disc2.get_limits()
##    limits = disc6.get_limits()
##    limits = disc4.get_limits(0)
#
#    disc1._map_regionid2regionlocs(0)
#    disc2._map_regionid2regionlocs(0)
#    disc6._map_regionid2regionlocs(0)
#    disc4._map_regionid2regionlocs(0)
#    disc5._map_regionid2regionlocs(0)
#    disc6._map_regionid2regionlocs(0)
#    disc7._map_regionid2regionlocs(0)
#    disc8._map_regionid2regionlocs(0)
#    disc9._map_regionid2regionlocs(0)

### test_perturbations 2016-02-23
#from pySpatialTools.Retrieve import KRetriever, CircRetriever,\
#    RetrieverManager
#from pySpatialTools.FeatureManagement import SpatialDescriptorModel
#from pySpatialTools.Discretization import GridSpatialDisc
#from pySpatialTools.Retrieve import OrderEleNeigh, SameEleNeigh
#from pySpatialTools.SpatialRelations.regiondistances_computers\
#    import compute_AvgDistanceRegions
#from pySpatialTools.SpatialRelations import RegionDistances
#from pySpatialTools.Retrieve import create_retriever_input_output

#    griddisc = GridSpatialDisc((100, 100), (0, 10), (0, 10))
#    locs = np.random.random((n, 2)) * 10
#    info_ret = {'order': 4}
#    contiguity = griddisc.get_contiguity()
#    contiguity = RegionDistances(contiguity)
#    ret = OrderEleNeigh(contiguity, info_ret)
#    relations, _data, symmetric, store =\
#        compute_AvgDistanceRegions(locs, griddisc, ret)
#    regdists = RegionDistances(relations=relations, _data=_data,
#                               symmetric=symmetric)
#    regret = OrderEleNeigh(regdists, {'order': 1})
#    m_in, m_out = create_retriever_input_output(griddisc.discretize(locs))
#    regret._output_map = [m_out]
#    agg_funct = lambda x, y: x.sum(0).ravel()
#    aggfeatures = features.add_aggregations((locs, griddisc), regret,
#                                            agg_funct)
#
#    feats_ret = FeaturesManager([features, aggfeatures], AvgDescriptor())


### test_sp_descriptormodels 2016-02-23

#    info_ret = {'order': 4}
#    contiguity = griddisc.get_contiguity()
#    contiguity = RegionDistances(relations=contiguity)
#    ret = OrderEleNeigh(contiguity, info_ret)
#    relations, _data, symmetric, store =\
#        compute_AvgDistanceRegions(locs, griddisc, ret)
#    regdists = RegionDistances(relations=relations, _data=_data,
#                               symmetric=symmetric)
#    regret = OrderEleNeigh(regdists, {'order': 1})
#    regdists = generate_random_relations(nx*ny, p0=0., p1=0.01, store='sparse')
#    regdists = generate_random_relations(nx*ny, p0=0., p1=0.01, store='sparse')
#    agg_funct = lambda x, y: x.sum(0).ravel()
#    aggfeatures = feats_ret.add_aggregations((locs, griddisc), regret,
#                                             agg_funct)
