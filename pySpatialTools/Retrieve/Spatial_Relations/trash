

##### regionNeighbourhood   2016-01-13 ##### 

"""
Neighbourhood definition module
-------------------------------
This module contains the class which performs the neighbourhood retrieval from
spatial data regarding possible aggregation.
Deals with regions aggregation interface and retrieve region neighbourhood.


TODO
----
Join into the Region Retriever if it is possible.

"""

import numpy as np


class RegionNeighbourhood:
    """Retriever of regions given a discretization and a region.
    """

    data = None
    locs_r = []
    discretizors = []
    distance_reg = []
    regs = []
    reg_distances = []

    def __init__(self, locs, discretizors, distance_reg, precomputed=True):
        """
        Parameters
        ----------
        locs: numpy.ndarray
            the location coordinates.
        discretizors: list of spatialdisc objects or list of numpy.ndarray
            a list of discretization measures.
        distance_reg: list of regiondistances objects
            the information to compute the distance between regions.
        """
        m = len(discretizors)
        ## Location
        self.data = locs
        ## Discretization by regions
        if type(discretizors[0]) != np.ndarray:
            self.locs_r = [discretizors.discretize(locs, m) for i in range(m)]
            self.discretizors = None
        else:
            self.locs_r = discretizors
        self.regs = [np.unique(self.locs_r[m]) for i in range(m)]
        self.precomputed = precomputed
        ## Region distances
        self.distance_reg = distance_reg

    def discretize(self, i_locs, i_disc=0):
        """Discretization of location to retrieve region of which the point
        belongs.

        Parameters
        ----------
        i_locs: int, numpy.ndarray
            the information of the points to discretize.
        i_disc: int
            the discretization we want to apply.

        Returns
        -------
        discs_i: int or numpy.ndarray
            the regions of each point discretized.

        """
        if self.locs_r is None:
            discs_i = self.discretizors[i_disc].discretize(i_locs)
        else:
            discs_i = self.locs_r[i_disc][i_locs]
        return discs_i
###################################################################################
###################################################################################
###################################################################################
###################################################################################

##### aux_regionmetrics   2016-01-12
def format_elements(elements, discretizor, retriever):
    """Format elements."""
    # Elements management
    if elements is True:
        # Filter by activated regions
        elements = discretizor.discretize(retriever.retriever.data)
        regions_id = np.unique(elements)
    elif elements is False:
        if type(retriever) == str:
            regions_id = np.unique(discretizor.get_regions_id())
        else:
            if retriever.tags is None:
                regions_id = np.arange(retriever.retriever.data.shape[0])
            else:
                regions_id = np.array(retriever.tags)
    elif type(elements) in [list, np.ndarray]:
        regions_id = np.unique(elements)
    # Transform elements into elements_i

    def compute_contiguity(self, retriever, locs, info_i):
        """Compute contiguity using the locations and a retriever.

        TODO
        ----
        Use correlation measure!!!!!
        """
        ## 0. Prepare inputs
        sh = locs.shape
        locs = locs if len(sh) > 1 else locs.reshape((1, sh[0]))
        ret = retriever(locs)
        regions_u = self.regions_id.unique()
        n_reg_u = regions_u.shape[0], regions_u.shape[0]
        regions_counts = np.zeros(n_reg_u)
        region_coincidences = np.zeros((n_reg_u, n_reg_u))
        ## 1. Compute matrix of coincidences
        regions = self.discretize(locs)
        for i in xrange(locs.shape[0]):
            r = regions[i]
            i_r = np.where(regions_u == r)
            neighs, dist = ret.retrieve_neighs(locs[i, :], info_i[i], True)
            regs = regions[neighs]
            i_regs = np.array([rs == regions_u for rs in regs])
            weights = compute_weigths(regs, dist)
            region_coincidences[i_r, i_regs] += weights
        contiguity = compute_measure(region_coincidences, regions_counts)
        return contiguity


def sparse_from_listaregneighs(lista, u_regs, symmetric):
    """Sparse representation matrix from a list of tuples of indices and
    values.
    """
    sh = (u_regs.shape[0], u_regs.shape[0])
    lista = np.array(lista)
    dts, iss, jss = lista[:, 2], lista[:, 0], lista[:, 1]
#    dts, iss, jss = [], [], []
#    for i in xrange(len(lista)):
#        print lista[i]
#        n_neigh = lista[i][1].shape[0]
#        for j in range(n_neigh):
#            dts.append(lista[i][0])
#            iss.append(lista[i][1][j])
#            jss.append(lista[i][2][j])
#            if symmetric:
#                dts.append(lista[i][0])
#                iss.append(lista[i][2][j])
#                jss.append(lista[i][1][j])
    dts, iss, jss = np.array(dts), np.array(iss), np.array(jss)
    relations = coo_matrix((dts, (iss, jss)), shape=sh)
    return relations




def regions_relation_points(locs, regions, retriever, info_ret):
    """Function which computes the spatial relations between regions
    considering the shared neighbourhoods of their points.

    TODO
    ----
    - Normalization coincidence

    """

    ## 0. Compute needed variables
    regs = np.unique(regions)
    count_reg = Counter(regions)
    n_reg = regs.shape[0]
    map_reg = dict(zip(regs, range(regs.shape[0])))

    ## 1. Count coincidences
    coincidence = np.zeros((n_reg, n_reg))
    for i in xrange(locs.shape[0]):
        neighs = retriever.retrieve_neighs(locs[i, :], info_ret[i], False)[0]
        count_neighs = Counter(regs[neighs])
        t_neighs = count_neighs.keys()
        for j_nei in t_neighs:
            res = count_neighs[j_nei]/count_reg[j_nei]

        for j in range(len(neighs)):
            coincidence[map_reg[regions[i]], map_reg[regions[neighs[j]]]] += 1.
    ## 2. Normalization of coincidences

    return coincidence
