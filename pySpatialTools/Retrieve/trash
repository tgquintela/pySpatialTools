
"""
"""

##########2016-02-23 Retrievers


    def _check_coord(self, i_locs, k=0, inorout=True):
        """Function to check if the input are coordinates or indices. The input
        is a coordinate when is an array with the same dimension that the pool
        of retrievable locations stored in retriever.data or in self.data.

        Parameters
        ----------
        i_locs: int, list of ints, numpy.ndarray or list of numpy.ndarray
            the locations information.

        Returns
        -------
        checker_coord: boolean
            if there are coordinates True, if there are indices False.

        """
        ## Get individuals
        if type(i_locs) == list:
            check_loc = i_locs[0]
        else:
            check_loc = i_locs
        ## Get checker
        if type(check_loc) in [int, np.int32, np.int64, np.ndarray]:
            if type(check_loc) != np.ndarray:
                checker_coord = False
            else:
                flag = inorout and not self._autoret
                self.locations.shape
                if flag:
                    d_sh = self.data.shape
                else:
                    d_sh = self.retriever[k].data.shape
                if len(check_loc.shape) == len(d_sh):
                    checker_coord = True
                else:
                    raise IndexError("Not correct shape for coordinates.")
        else:
            checker_coord = None
        return checker_coord

    def _retrieve_neighs_reg(self, elem_i, i_disc=0, lim_distance=None,
                             maxif=True, ifdistance=True):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: or for particular use.

        Parameters
        ----------
        elem_i: int or numpy.ndarray
            the elements we want to get its neighbor element.
        i_disc: int
            the discretization we want to apply.
        lim_distance: float
            the bound distance to define neighbourhood.
        maxif: boolean
            if True the bound is the maximum accepted, if False it is the
            minimum.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.
        """
        neighs, dists = self.retriever.retrieve_neighs(elem_i)
        if neighs.any():
            if lim_distance is None:
                logi = np.ones(len(list(dists))).astype(bool)
            else:
                if maxif:
                    logi = dists < lim_distance
                else:
                    logi = dists > lim_distance
            neighs = neighs[logi]
            dists = dists[logi]
        neighs = neighs.ravel()
        return neighs, dists


    def _retrieve_neighs_reg(self, elem_i, i_disc=0):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: or particular use.

        Parameters
        ----------
        elem_i: int or numpy.ndarray
            the element we want to get its neighsbour elements.
        i_disc: int
            the discretization we want to apply.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.
        """
        if type(elem_i) == np.ndarray:
            neighs, dists = np.array(elem_i), np.array([0])
        else:
            neighs = np.array(self.retriever.data[elem_i])
            dists = np.array([0]*neighs.shape[0])
        neighs = neighs.ravel()
        return neighs, dists

    def _retrieve_neighs_reg(self, elem_i, i_disc=0, order=0,
                             exactorlimit=False):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: and suspicious of bad results.

        Parameters
        ----------
        elem_i: int or np.ndarray
            the element we want to get its neighsbour elements.
        order: int
            the order we want to retrieve the object.
        exactorlimit: boolean
            if True we retrieve the neighs in this exact order, if False we
            retrieve the neighs up to this order (included).

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.

        """
        elem_i = self.retriever.data[elem_i] if type(elem_i) == int else elem_i
        ## 0. Needed variables
        neighs, dists, to_reg = [], [], [elem_i]
        ## Crawling in net variables
        to_reg, to_dists = [elem_i], [self.retriever._inv_null_value]
        reg_explored = []

        ## 1. Crawling in network
        for o in range(order+1):
            neighs_o, dists_o = [], []
            for i in range(len(to_reg)):
                to_reg_i = np.array(to_reg[i])
                neighs_o, dists_o = self.retriever.retrieve_neighs(to_reg_i)
                if self.retriever._distanceorweighs:
                    dists_o += to_dists[i]
                else:
                    dists_o += 1
            ## Add to globals
            n_o = len(neighs_o)
            idx_excl = [i for i in range(n_o) if neighs_o[i]
                        not in reg_explored]
            to_reg = [neighs_o[i] for i in range(n_o) if i not in idx_excl]
            to_dists = [dists_o[i] for i in range(n_o) if i not in idx_excl]
            reg_explored += to_reg
            ## Add to results
            neighs.append(neighs_o)
            dists.append(dists_o)

        ## Exact or limit order formatting output
        if exactorlimit:
            neighs = neighs_o
            dists = dists_o

        neighs, dists = np.hstack(neighs).ravel(), np.hstack(dists)
        return neighs, dists



##########2016-01-14


    def format_output(self, i_loc, neighs, dists):
        """Function which acts as a formatter of the output required by the
        design of the retriever object.

        Parameters
        ----------
        i_loc: int or numpy.ndarray
            the location or the point id.
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood points or regions.
        dists: numpy.ndarray
            the distances between points or regions.

        """
        ## Format output shape
        if not self.regiontype_output:
            n = self.retriever.data.shape[0]
            logi = np.zeros(n).astype(bool)
            dists_i = np.zeros(n)
            for j in range(len(neighs)):
                logi_j = self.locs_r == neighs[j]
                logi = np.logical_or(logi, logi_j)
                dists_i[logi_j] = dists[j]
            neighs = np.where(logi)[0]
            dists = dists_i[logi]
        # Exclude auto point
        neighs, dists = self.exclude_auto(i_loc, neighs, dists)
        # Compute point-point distance
        point_i = self.get_loc_i(i_loc)
        if self.ifcdist:
            dists = cdist(point_i, self.retriever.data[neighs, :])
        return neighs, dists


#    def discretize(self, i_locs, unique=True):
#        """This function transform the input i_locs to discs_i. This discretize
#        function at this level has to deal with different inputs: (i_reg,
#        i_locs, locs_i) and different possibilities: (precomputed, autolocs)
#
#        Parameters
#        ----------
#        i_locs: int, numpy.ndarray, list or int or list of numpy.ndarray
#            the location expressed as regions, id_points or the coordinates of
#            the points.
#
#        Returns
#        -------
#        discs_i: int, list of ints
#            the region ids of the locations specified.
#
#        """
#        if i_locs is None:
#            return None
#        if self.regiontype_input:
#            discs_i = i_locs
#        else:
#            if not self.check_coord(i_locs):
#                if self.precomputed:
#                    if self.autolocs:
#                        discs_i = self.retriever.locs_r[i_locs]
#                    else:
#                        discs_i = self.locs_r[i_locs]
#                else:
#                    if self.autolocs:
#                        locs_i = self.retriever.data[i_locs, :]
#                    else:
#                        locs_i = self.locs[i_locs, :]
#                    discs_i = self.retriever.discretize(locs_i)
#            else:
#                discs_i = self.retriever.discretize(i_locs)
#        return discs_i
#
#    def retrieve_neighs_spec(self, loc_i, info_i, ifdistance=False):
#        """Function of region retrieving.
#
#        Parameters
#        ----------
#        loc_i: int or numpy.ndarray
#            the location or the point id.
#        info_i: optional
#            information of retrieving points.
#        ifdistance: boolean
#            compute distance of the neighbours.
#
#        Returns
#        -------
#        neighs: numpy.ndarray
#            the ids of the neighbourhood regions.
#        dists: numpy.ndarray
#            the distances between regions.
#
#        """
#        ## Discretize location i
#        regs_i = self.discretize(loc_i)
#        ## Retrieve neighbourhood regions
#        neighs, dists = self.retrieve_neigh_r(regs_i, info_i, ifdistance)
#        return neighs, dists




##########2016-01-12

###############################################################################
############################## Region Retrievers ##############################
###############################################################################
class RegionRetriever(Retriever):
    """Retriever class for region-based retrievers.

    TODO:
    -----
    Non-unique discretization.

    """

    typeret = 'region'
    default_ret_val = {}
    locs_r = None

    def __init__(self, locs, discretizors, distance_reg, pars_ret=None,
                 autolocs=None, info_ret=None, flag_auto=True,
                 ifdistance=False, info_f=None, precomputed=True,
                 regiontype_input=True, ifcdist=True, regiontype_output=True):
        "Creation a point retriever class method."
        # Retrieve information
        pars_ret = self.format_pars_ret(pars_ret, precomputed)
        self.retriever = define_Regretriever(locs, discretizors, distance_reg,
                                             **pars_ret)
        self.info_ret = self.default_ret_val if info_ret is None else info_ret
        self.info_f = info_f
        self.ifdistance = ifdistance
        # Location information
        self.autolocs = True if autolocs is None else False
        self.locs = None if autolocs is None else autolocs
        self.locs_r = self.discretize(self.locs) if precomputed else None
        # Input-Output information
        self.flag_auto = flag_auto
        self.regiontype_input = True
        self.regiontype_output = True
        self.ifcdist = True
        # Extra info
        self.precomputed = precomputed

    def discretize(self, i_locs, unique=True):
        """This function transform the input i_locs to discs_i. This discretize
        function at this level has to deal with different inputs: (i_reg,
        i_locs, locs_i) and different possibilities: (precomputed, autolocs)

        Parameters
        ----------
        i_locs: int, numpy.ndarray, list or int or list of numpy.ndarray
            the location expressed as regions, id_points or the coordinates of
            the points.

        Returns
        -------
        discs_i: int, list of ints
            the region ids of the locations specified.

        """
        if i_locs is None:
            return None
        if self.regiontype_input:
            discs_i = i_locs
        else:
            if not self.check_coord(i_locs):
                if self.precomputed:
                    if self.autolocs:
                        discs_i = self.retriever.locs_r[i_locs]
                    else:
                        discs_i = self.locs_r[i_locs]
                else:
                    if self.autolocs:
                        locs_i = self.retriever.data[i_locs, :]
                    else:
                        locs_i = self.locs[i_locs, :]
                    discs_i = self.retriever.discretize(locs_i)
            else:
                discs_i = self.retriever.discretize(i_locs)
        return discs_i

    def retrieve_neighs_spec(self, loc_i, info_i, ifdistance=False):
        """Function of region retrieving.

        Parameters
        ----------
        loc_i: int or numpy.ndarray
            the location or the point id.
        info_i: optional
            information of retrieving points.
        ifdistance: boolean
            compute distance of the neighbours.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        """
        ## Discretize location i
        regs_i = self.discretize(loc_i)
        ## Retrieve neighbourhood regions
        neighs, dists = self.retrieve_neigh_r(regs_i, info_i, ifdistance)
        return neighs, dists

    def retrieve_neigh_r(self, regs_i, info_i={}, ifdistance=False):
        """Retrieve regions neighbourhood.
        """
        info_i = self.retriever.format_info_i_reg(info_i)
        neighs_r, dists_r = self.retriever.retrieve_neigh_reg(regs_i, **info_i)
        dists_r = dists_r if ifdistance else None
        return neighs_r, dists_r

    def format_output(self, i_loc, neighs, dists):
        """Function which acts as a formatter of the output required by the
        design of the retriever object.

        Parameters
        ----------
        i_loc: int or numpy.ndarray
            the location or the point id.
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood points or regions.
        dists: numpy.ndarray
            the distances between points or regions.

        """
        ## Format output shape
        if not self.regiontype_output:
            n = self.retriever.data.shape[0]
            logi = np.zeros(n).astype(bool)
            dists_i = np.zeros(n)
            for j in range(len(neighs)):
                logi_j = self.locs_r == neighs[j]
                logi = np.logical_or(logi, logi_j)
                dists_i[logi_j] = dists[j]
            neighs = np.where(logi)[0]
            dists = dists_i[logi]
        # Exclude auto point
        neighs, dists = self.exclude_auto(i_loc, neighs, dists)
        # Compute point-point distance
        point_i = self.get_loc_i(i_loc)
        if self.ifcdist:
            dists = cdist(point_i, self.retriever.data[neighs, :])
        return neighs, dists

    def format_pars_ret(self, pars_ret, precomputed):
        pars_ret = {'precomputed': precomputed}
        return pars_ret


def define_Regretriever(locs, discretizor, distance_reg, precomputed=True):
    regretriever = RegionNeighbourhood(locs, discretizor, distance_reg,
                                       precomputed)
    return regretriever




###########2016-01-07

### RegNeigh
#    def retrieve_neigh_i(self, i_loc, info_i={}, ifdistance=False):
#        '''Retrieve the element neighbors of a point.
#
#        Parameters
#        ----------
#        i_loc: int, numpy.ndarray: shape(2,)
#            the location of the point we want to retrieve their neighbors.
#
#        '''
#        ## 0. Proper format
#        info_i = self.format_info_i_reg(info_i, ifdistance)
#        ## 1. Get regions of i_locs
#        disc_i = self.discretize(i_loc)
#        ## 2. Compute region neighbours
#        neigh, dists = self.retrieve_neigh_r(disc_i, info_i, ifdistance)
#        ## 3. Format properly
#        neigh_i, dists_i = self.format_output(i_loc, neigh, dists)
#        return neigh_i, dists


###########2016-01-06


class Neighbourhood:
    """
    Retrieve neighs. It is the main class for retrieve neighbourhood. It could
    retrieve the nearer neighbours in a flat space or the nearer neighbourhoods
    in the pre-discretized space.

    TODO
    ----
    - init
    - precomputed
    - retrieve neighs
    - compute_feats

    """
    aggretrievers = []
    locs = None
    info_ret = None

    precomputed = False

    def __init__(self, retrievers):
        self.retrievers = retrievers

    def set(self, locs, info_ret, auto=True):
        'TODO: Auto, to save memory of locs.'
        self.locs = locs
        self.info_ret = info_ret

    def retrieve_neigh(self, i, typeret):
        point_i = self.locs[i, :].reshape(1, self.locs.shape[1])
        info_i = self.info_ret[i]
        neighs, dists = self.retrievers[typeret].retrieve_neighs(point_i,
                                                                 info_i, True)
        return neighs, dists

    def transform_i(self, i):
        disc_i = discretize(i)
        return disc_i

    def get_neighbourhood(self, i):
        get_region_neighbours(disc_i)
        self.transform_i(i)

    def compute_feats_global(self):
        ## Needs the feature model.
        pass



############ 2015-12-28
class Neighbourhood():
    """
    Retrieve neighs. It is the main class for retrieve neighbourhood. It could
    retrieve the nearer neighbours in a flat space or the nearer neighbourhoods
    in the pre-discretized space.
    """
    aggdiscretizor = None  # discretize space
    aggretriever = None  # aggregation retriever, to retrieve aggregation neigh
    aggfeatures = None  # aggregation features.
    agglocs = None  # locations of the aggregations.

    retriever = None  # main retriever for point2point

    cond_funct = lambda xself, xbool: xbool

    def __init__(self, retriever, typevars, df, reindices, aggretriever,
                 funct=None, discretizor=None):
        self.define_mainretriever(retriever)
        self.define_aggretriever(typevars, df, reindices, aggretriever, funct,
                                 discretizor)

    def define_mainretriever(self, retriever):
        """Main retriever or directed retriever definition. No aggregation
        considered.

        Parameters
        ----------
        retriever: pySpatialTools.retriever class
            the retriever class.

        """
        self.retriever = retriever

    def define_aggretriever(self, typevars, df, reindices, aggretriever,
                            funct=None, discretizor=None):
        """Main function to define an aggretriever. It will save the needed
        information in order to retrieve the neighbours aggregate regions.

        Parameters
        ----------
        typevars: dict
            dictionary with the variables types (loc_vars, feat_vars)
        df: pd.DataFrame
            the data to study.
        reindices: array_like
            the information of permutations.
        aggretriever: retriever object
            the object to retrieve the nearer neighbourhoods.
        funct: function
            function to aggregate 
        discretizor: 

        """
        self.aggdiscretizor, self.aggretriever = discretizor, aggretriever
        if discretizor is not None:
            locs = df[typevars['loc_vars']].as_matrix()
            agg_arr = discretizor.map2id(locs)
            agg_arr = pd.DataFrame(agg_arr, columns=['agg_var'])
            ## Ouputs
            df = pd.concat([df, agg_arr], axis=1)
            typevars['agg_var'] = 'agg_var'
        ## Creation of the aggregator object and aggregation
        agg = Aggregator(typevars)
        agglocs, aggfeatures = agg.retrieve_aggregation(df, reindices, funct)
        ## Instantiation aggretriever
        self.aggretriever = aggretriever(agglocs)
        ## Correction of the agglocs if there is a discretizor
        if discretizor is not None:
            agglocs = discretizor.map2aggloc(agglocs)
        self.aggfeatures, self.agglocs = aggfeatures, agglocs

    def retrieve_neighs(self, point_i, cond_i, info_i):
        """Retrieve the neighs information and the type of retrieving.
        Type of retrieving:
        - aggfeatures: aggregate
        - indices of neighs: neighs_i
        """
        if len(point_i.shape) == 1:
            point_i = point_i.reshape(1, point_i.shape[0])
        typereturn = self.get_type_return(cond_i)
        if typereturn:
            neighbourhood, dist = self.retrieve_neighs_agg(point_i, info_i[1])
        else:
            neighbourhood, dist = self.retrieve_neighs_i(point_i, info_i[0])
        typereturn = 'aggregate' if typereturn else 'individual'
        #neighbourhood = [int(e) for e in neighbourhood]
        return neighbourhood, dist, typereturn

    def retrieve_neighs_agg(self, point_i, info_i):
        "Retrieve the correspondent regions."
        ## Discretizor
        out = self.aggretriever.retrieve_neighs(point_i, info_i)
        return out

    def retrieve_neighs_i(self, point_i, info_i):
        "Retrieve the neighs."
        return self.retriever.retrieve_neighs(point_i, info_i)

    ###########################################################################
    ########################## Condition aggregation ##########################
    ###########################################################################
    def set_aggcondition(self, f):
        "Setting condition function for aggregate data retrieval."
        self.cond_funct = f

    def get_type_return(self, cond_i):
        """Apply condition setted for deciding if neighbourhood of point i is
        retrieved aggregated or not.

        Parameters
        ----------
        cond_i: arbitrary
            information for decide retrieval aggregated or not.

        Returns
        -------
        output: boolean
            retrieve aggregated or not.

        """
        ## TODO: Add the possibility to not be in aggregate and return False
        return self.cond_funct(cond_i)


