
"""
"""
######## 2016-04-26 Retrievers

    def _get_idx_from_loc_indata(self, loc_i, kr=0):
        """Get indices from stored data."""
        ### Check
        indices = []
        if type(self.data_input) == list:
            for j in range(len(self.data_input)):
                if self.data_input[j] == loc_i:
                    indices.append(j)
        else:
            print '='*20, loc_i, type(loc_i)
            aux_ind = np.where(self.data_input == loc_i)[0]
            if len(aux_ind):
                indices = list(aux_ind)
            print '-'*20, indices
#        print 'm'*20, loc_i, self.data_input
#        if type(self.data_input) == np.ndarray:
#            indices = []
#            aux_ind = np.where(self.data_input == loc_i)[0]
#            if len(indices):
#                indices = aux_ind
##            for l in loc_i:
##                indices.append(np.where(self.data_input == l)[0])
##            indices = np.concatenate(indices)
##            # WARNING: TODO: Probably outside when get_idx is used
##            if len(indices) != len(np.unique(indices)):
##                indices = np.unique(indices)
##            indices = list(indices)
#        elif type(self.data_input) == list:
#            indices = []
#            for j in range(len(self.data_input)):
#                if self.data_input[j] == loc_i:
#                    indices.append(j)
##            for l in loc_i:
##                for i in range(len(self.data_input)):
##                    if self.data_input[i] == l:
##                        indices.append(i)
#        else:
#            indices = []
#            for l in loc_i:
#                indices.append(np.where(self.data_input == l))
#            indices = np.concatenate(indices)
        return indices

######## 2016-04-13 ImplicitRetriever, WindowsRetriever

#    def __iter__(self):
#        ## Prepare iteration
#        bool_input_idx = True
#        self._format_preparators(bool_input_idx)
#        self._constant_ret = True
#        self._format_retriever_function(bool_input_idx)
#        ## Prepare indices
#        indices = split_parallel(np.arange(self._n0), self._max_bunch)
#        ## Iteration
#        for idxs in indices:
#            neighs = self.retrieve_neighs(idxs)
#            yield indices, neighs

######## 2016-04-11 Retriever
    ###########################################################################
#    def _get_loc_from_idx_locations(self, i_loc, kr=0):
#        """Specific interaction with an storage of Locations type."""
#        loc_i = np.array().reshape((1, sh[1]))

#    def _get_loc_from_idx_kdtree(self, i):
#        """Not list indexable interaction with data."""
#        loc_i = np.array(self.retriever[kr].data[i])
#        return loc_i

#    def _get_loc_from_idx_virtual(self, i):
#        """Get location from indice in virtual data retriever. List indexable.
#        """
#        loc_i = self.retriever[kr].get_locations_input(i_loc)
#        return loc_i

#    def _get_loc_from_idx_indata(self, i):
#        """Get location from indata array stored in the class. List indexable.
#        """
#        loc_i = self.data_input[i]
#        return loc_i

    ###########################################################################

#    def _get_loc_from_idx_real_outdata_listind(self, i_loc, kr=0):
#        """Specific interaction with the data stored in retriever object."""
#        data
#
#    def _get_loc_from_idx_virtual(self, i_loc, kr=0):
#        """Get location from indice in virtual data retriever."""
#        loc = self.retriever[kr].get_locations_input(i_loc)
#        return loc
#

#    def _get_loc_from_idx_real(self, i_loc, kr=0):
#        """Get location from indice in explicit data retriever."""
#        loc = np.array(self.retriever[kr].data_input[i_loc])
#        return loc


#    def _get_indice_i_general_from_objects(loc_i, kr=0):
#        """Get indice of spatial information from spatial objects information.
#        """
#        return i_loc
#
#    def _get_indice_i_general_from_coords(loc_i, kr=0):
#        """Get indice of spatial information from spatial coordinates."""
#        return i_loc
#
#    def _get_indice_i_general(self, loc_i, kr=0):
#        """Obtain the indices from the elements, element-wise."""
#        try:
#            indice = self._get_indice_i_virtual(loc_i, kr)
#        except:
#            try:
#                indice = self._get_indice_i_global(loc_i, kr)
#            except:
#                indice = self._get_indice_i_elementwise(loc_i, kr)
#        return indice
#
#    def _get_indice_i_virtual(self, loc_i, kr=0):
#        """Get indice for virtual (not computed explicitely) data."""
#        indices = self.retriever[kr].get_indices_input(loc_i)
#        return indices
#
#    def _get_indice_i_global(self, loc_i, kr=0):
#        """Global search from elements."""
#        indices = np.where(self.retriever[kr].data_input == loc_i)[0]
#        return indices
#
#    def _get_indice_i_elementwise(self, loc_i, kr=0):
#        """Obtain the indices from the elements element-wise."""
#        indices = np.where([self.retriever[kr].data_input[i] == loc_i
#                            for i in range(len(self.retriever[kr].data))])
#        return indices
#
#    def _get_indices_i_real_array(self, loc_i, kr=0):
#        """Brute comparison between loc_i in array form and array storage."""
#        indices = []
#        for loc_ii in loc_i:
#            aux_i = np.where(np.all(self.retriever[kr].data_input == loc_ii,
#                                    axis=1))[0]
#            indices.append(aux_i)
#        indices = np.concatenate(indices)
#        if len(np.unique(indices)) != len(indices):
#            indices = np.unique(indices)
#        indices = list(indices)
#        return indices
#
#    def _get_indices_i_real_list(self, loc_i, kr=0):
#        """Dummy sequential search and comparison between all the elements
#        stored and the initial loc_i."""
#        indices = []
#        for loc_ii in loc_i:
#            for i in range(len(self.retriever[kr])):
#                aux_i = self.retriever[kr].data_input[i] == loc_ii
#                if aux_i:
#                    indices.append(i)
#        if len(np.unique(indices)) != len(indices):
#            indices = np.unique(indices)
#        indices = list(indices)
#        return indices
#
#    def _get_indices_i_virtual(self, loc_i, kr=0):
#        """Get indices for virtual (not computed explicitely) data."""
#        indices = self.retriever[kr].get_indices_input(loc_i)
#        return indices

######## 2016-04-10 Retriever

    def _get_loc_i_general(self, i_loc, k=0, inorout=True):
        """Get element spatial information. Generic function."""
        ## 0. Needed variable computations
#        ifdata = inorout and not self._autodata
#        sh = self.data_input.shape
        int_types = [int, np.int32, np.int]
#        if ifdata:
#            flag = isinstance(self.data, Locations)
#        else:
#            flag = isinstance(self.retriever[k].data, Locations)
        ## 1. Loc retriever
        # If indice
        if type(i_loc) in int_types:
            loc_i = self._get_loc_from_idx(i_loc)
#            try:
#                if flag:
#                    if ifdata:
#                        i_loc = self.data_input[i_loc].location
#                        i_loc = np.array(i_loc).reshape((1, sh[1]))
#                    else:
#                        i_loc = self.data_input[i_loc].location
#                        i_loc = np.array(i_loc).reshape((1, sh[1]))
#                else:
#                    if ifdata:
#                        loc_i = np.array(self.data[i_loc]).reshape((1, sh[1]))
#                    else:
#                        loc_i = np.array(self.retriever[k].data[i_loc])
#                        loc_i = loc_i.reshape((1, sh[1]))
#            except:
#                if ifdata:
#                    loc_i = self.data_input[i_loc]
        # If List
        elif type(i_loc) == list:
            # Empty list
            if len(i_loc) == 0:
                return i_loc
            # if list of indices
            if type(i_loc) in int_types:
                loc_i = self._get_loc_from_idx(i_loc)
            # if list of objects data
            else:
                loc_i = i_loc
        # if coordinates
        elif type(i_loc) == np.ndarray:
            loc_i = self._get_loc_dummy_array(i_loc, k)
        # if locations objects
        elif isinstance(i_loc, Locations):
            loc_i = self._get_loc_dummy_locations(i_loc, k)
        else:
            loc_i = self._get_loc_dummy(i_loc)
        return loc_i

######## 2016-03-08 Retriever
    def _exclude_auto(self, i_loc, neighs, dists, kr=0):
        """Exclude auto elements if there exist in the neighs retrieved.
        This is a generic function independent on the type of the element.
        """
        ## 0. Detect input i_loc and retrieve to_exclude_elements list
        # If it is an indice
        if type(i_loc) in [int, np.int32, np.int64]:
            to_exclude_elements = [[i_loc]]
        elif type(i_loc) == list:
            to_exclude_elements = [list(i_loc[0])]
        # If it is an element spatial information
        else:
            to_exclude_elements = self._build_excluded_elements(i_loc, kr)
        ## 1. Excluding task
#        ndim = len(np.array(neighs).shape)
#        n_p = len(neighs) if ndim == 1 else np.array(neighs).shape[1]
#        ## Prepare neighs and dists
#        neighs = np.array(neighs)
#        neighs = neighs.reshape((1, n_p)) if ndim == 1 else neighs
#        neighs = [[neighs[iss_i][i] for i in range(n_p)]
#                  for iss_i in range(len(neighs))]
#        if dists is not None:
#            dists = dists.reshape((1, n_p)) if ndim == 1 else dists
#            dists = [[dists[nei][i] for i in range(n_p)]
#                     for nei in range(len(dists))]

        for iss_i in range(len(to_exclude_elements)):
            n_iss_i = len(neighs[iss_i])
            idxs_exclude = [i for i in xrange(n_iss_i)
                            if neighs[iss_i][i] in to_exclude_elements[iss_i]]

            neighs[iss_i] = [neighs[iss_i][i] for i in xrange(n_iss_i)
                             if i not in idxs_exclude]
            if dists is not None:
                dists[iss_i] = [dists[iss_i][i] for i in xrange(n_iss_i)
                                if i not in idxs_exclude]
#        neighs, dists = np.array(neighs), dists
        return neighs, dists

    def _build_excluded_elements(self, i_loc, kr=0):
        """Build the excluded points from i_loc if it is not an index."""
        if type(i_loc) == np.ndarray:
            sh = i_loc.shape
            i_loc = i_loc if len(sh) == 2 else i_loc.reshape(1, sh[0])
        try:
            logi = np.all(self.retriever[kr].data == i_loc, axis=1).ravel()
        except:
            try:
                logi = np.all(self.retriever[kr].data == i_loc)
            except:
                n = len(self.retriever[kr].data)
                logi = np.array([self.retriever[kr].data[i] == i_loc
                                 for i in xrange(n)])
        assert len(logi) == len(self.retriever[kr].data)
        to_exclude_points = [np.where(logi)[0]]
        return to_exclude_points


######## 2016-03-01 Auxiliar windows retriever

#def get_extrem_indices(extremes, coord2ind):
#    """Get the indices of the extremes."""
#    ## 0. Get formatted indices of extrems
#    ndim = len(extremes)
#    extind = []
#    for p in product(*[range(2) for i in range(ndim)]):
#        extind.append(coord2ind(extremes[np.arange(ndim), np.array(p)]))
#    extind = np.sort(np.array(extind).astype(int))
#    extremes_ind = np.zeros((len(extind)-1, 2)).astype(int)
#    for i in range(len(extind)-1):
#        extremes_ind[i] = np.array([extind[i], extind[i+1]])
#    return extremes_ind


def get_borders_regularneighs_grid(shape, diff):
    assert(len(shape) == len(diff))
    borders, ranges = [], []
    for dim in range(len(shape)):
        borders_dim, ranges_dim =\
            get_borders_regularneighs_grid_ind(diff[dim], shape[dim])
        ranges.append(ranges_dim)
        borders.append(borders_dim)
    return borders, ranges


def get_borders_regularneighs_grid_ind(diff_dim, shape_m):
    maxi = np.max(np.abs(diff_dim))
    ranges, borders = [], []
    for m in range(maxi):
        ranges_m, borders_m = [], []
        ## Beginning borders
        boolean = np.array(diff_dim) + m >= 0
        aux_m = [diff_dim[i] for i in range(len(diff_dim)) if boolean[i]]
        if len(aux_m) < len(diff_dim) and np.any(boolean):
            ranges_m.append(aux_m)
            borders_m.append(m)
        else:
            ranges_m.append([])
            borders_m.append(None)

        ## Ending borders
        boolean = m - np.array(diff_dim) >= 0
        aux_m = [diff_dim[i] for i in range(len(diff_dim)) if boolean[i]]
        if len(aux_m) < len(diff_dim) and np.any(boolean):
            ranges_m.append(aux_m)
            borders_m.append(shape_m-1-m)
        else:
            ranges_m.append([])
            borders_m.append(None)
        ranges.append(ranges_m)
        borders.append(borders_m)
    return borders, ranges



def create_hypercuble_borders(borders, ranges, shape, g_range):
    new_borders, new_ranges = [], []
    for p in product(*[range(2) for i in range(len(borders))]):
        aux = [borders[i][p[i]] for i in range(len(p))]
        aux_r = [ranges[i][p[i]] for i in range(len(p))]
        if not np.any([a is None for a in aux]):
            new_borders.append(tuple(aux))
            new_ranges.append(tuple(aux_r))
    ## Only when there are only by one
    for j in range(len(borders)):
        if (len(ranges[j]) + 1) != len(g_range[j]):
            continue
        start = 0 if borders[j][0] is None else borders[j][0]+1
        stop = shape[j] if borders[j][1] is None else borders[j][1]
        for p in product(*[range(2) for i in range(len(borders)-1)]):
            new_borders_j, new_ranges_j = [[]]*len(borders), [[]]*len(borders)
            new_borders_j[j], new_ranges_j[j] = slice(start, stop), g_range[j]
            for k in range(len(borders)):
                if k < j:
                    new_borders_j[k] = borders[k][p[k]]
                    new_ranges_j[k] = ranges[k][p[k]]
                elif k > j:
                    new_borders_j[k] = borders[k][p[k-1]]
                    new_ranges_j[k] = ranges[k][p[k-1]]
            if not np.any([e is None for e in new_borders_j]):
                new_borders.append(tuple(new_borders_j))
                new_ranges.append(tuple(new_ranges_j))
    return new_borders, new_ranges

#def new_get_irregular_extremes(diff, shape):
#    init_points, init_ranges = [], []
#    for dim in range(len(diff)):
#        init = -1 - diff[dim][0]
#        init = None if init < 0 else init
#        endit = shape[dim] - diff[dim][-1]
#        endit = None if endit >= shape[dim] else endit
#        init_points.append([init, endit])
#        init_r = [dr for dr in diff[dim] if dr > diff[dim][0]]
#        endit_r = [dr for dr in diff[dim] if dr < diff[dim][-1]]
#        init_ranges.append([init_r, endit_r])
#    points, ranges = [init_points], [init_ranges]
#    d_max = np.max([np.max(np.abs(e)) for e in diff])
#    for d in range(1, d_max):
#        points_d, ranges_d = [], []
#        for dim in range(len(diff)):
#            init = init_points[dim][0] - d
#            init = None if init < 0 else init
#            endit = init_points[dim][1] + d
#            endit = None if endit >= shape[dim] else endit
#            init_r = [dr for dr in diff[dim] if dr > diff[dim][0]+d
#                      or dr >= 0]
#            endit_r = [dr for dr in diff[dim] if dr < diff[dim][-1]-d
#                       or dr <= 0]
#            points_d.append([init, endit])
#            ranges_d.append([init_r, endit_r])
#        points.append(points_d)
#        ranges.append(ranges_d)
#    return points, ranges

#def new_get_borders_from_irregular_extremes(extremes, shape, grange, ranges):
#    """Get borders from irregular extremes."""
#    new_borders, new_ranges = [], []
#    ndim = len(extremes[0])
#    for d in range(len(extremes)):
#        for p in product(*[range(2) for dim in range(ndim)]):
#            aux = [extremes[d][i][p[i]] is None for i in range(len(p))]
#            if not np.all(aux):
#                aux, aux_r = [], []
#                for dim in range(len(p)):
#                    aux_dim = extremes[d][dim][p[dim]]
#                    aux_rdim = ranges[d][dim][p[dim]]
#                    if aux_dim is None:
#                        aux_dim = shape[dim]-1 if p[dim] else 0
#                    aux.append(aux_dim)
#                    aux_r.append(aux_rdim)
#                new_borders.append(tuple(aux))
#                new_ranges.append(tuple(aux_r))
#        for n_i in range(1, ndim):
#            ## Possible combinations
#            for dims in combinations(range(ndim), n_i):
#                if not dims:
#                    continue
#                dims = list(dims)
#                no_dims = [i for i in range(ndim) if i not in dims]
#                ## Check if it is possible to build slices
##                aux = []
##                for dim in dims:
##                    aux.append(np.all([e is None for e in extremes[d][dim]]))
##                if np.any(aux):
##                    continue
#                for p in product(*[range(2) for nodim in no_dims]):
#                    ## Creation slices
#                    aux_bor, aux_ranges = [[]]*ndim, [[]]*ndim
#                    for dim in dims:
#                        aux = extremes[d][dim]
#                        start = 0 if aux[0] is None else aux[0]+1
#                        stop = shape[dim] if aux[1] is None else aux[1]
##                        for i in range(start, -grange[dim][0]):
##                            for j in range(stop, shape[dim] - grange[dim][-1]):
#                        aux_bor[dim] = slice(start, stop)
##                        init = grange[dim][0] if grange[dim][0] < 0 else 0
##                        fin = grange[dim][-1] if grange[dim][-1] > 0 else 0
#
#                        aux_bor[dim] = slice()
#                        aux_ranges[dim] = grange[dim]
#                        aux_ranges[dim] = [e for e in grange[dim]
#                                           if e >= -start
#                                           and e < shape[dim]-stop]
#                    ## Creation of fixes
#                    # Check if there is None
#                    aux = extremes[d]
#                    aux = [aux[no_dims[i]][p[i]] is None for i in range(len(p))]
#                    if np.any(aux):
#                        continue
#                    for i in range(len(p)):
#                        aux_bor[no_dims[i]] = extremes[d][no_dims[i]][p[i]]
#                        aux_ranges[no_dims[i]] = ranges[d][no_dims[i]][p[i]]
#                    new_borders.append(tuple(aux_bor))
#                    new_ranges.append(tuple(aux_ranges))
#    return new_borders, new_ranges
#

#def build_border_from_slices(extremes_i, ranges_i):
#    i_sl = [i for i in range(len(extremes_i))
#            if isinstance(extremes_i[i], slice)]
#    [ranges_i]
#
#    sizes = np.array([np.prod([len(e) for e in r]) for r in ranges_i])




#
#def get_irregular_indices_grid(shape, l, center, excluded):
#    """Getting not neighbourhood complete indices."""
#    c = center
#    l = np.array(l) if '__len__' in dir(l) else np.array(len(shape)*[l])
#    c = np.array(c) if '__len__' in dir(c) else np.array(len(shape)*[c])
#    diff = get_relative_neighs(shape, l, c, excluded)
#    borders, ranges = get_borders_regularneighs_grid(shape, diff)
#    new_borders, new_ranges = [], []
#    comb = [range(len(borders[i])) for i in range(len(borders))]
#    for p in product(*comb):
#        borders_p = [borders[i][p[i]] for i in range(len(p))]
#        ranges_p = [ranges[i][p[i]] for i in range(len(p))]
#        borders_p, ranges_p =\
#            create_hypercuble_borders(borders_p, ranges_p, shape, diff)
#        new_borders.extend(borders_p)
#        new_ranges.extend(ranges_p)
##        borders_p.append([borders[i][p[i]] for i in range(len(p))])
##        ranges_p.append([ranges[i][p[i]] for i in range(len(p))])
##        size_nei_p.append(np.prod([orders[i][p[i]] for i in range(len(p))]))
#    sizes = [np.prod([len(r) for r in range_i]) for range_i in new_ranges]
#    return new_borders, new_ranges, sizes




########## 2016-03-01 WindowsRetriever
######################################

#                start = 0 if aux[0] is None else aux[0]+1
#                stop = shape[dim] if aux[1] is None else aux[1]+1
#                aux_bor, aux_ranges = [[]]*ndim, [[]]*ndim
#                aux_bor[dim], aux_ranges[dim] = slice(start, stop), grange[dim]
#                i = 0
#                for nodim in no_dims:
#                    if aux_dim < dim:
#                        aux_bor[aux_dim] = extremes[d][aux_dim][p[aux_dim]]
#                        aux_ranges[aux_dim] = ranges[d][aux_dim][p[aux_dim]]
#                    elif aux_dim > dim:
#                        aux_bor[aux_dim] = extremes[d][aux_dim][p[aux_dim-1]]
#                        aux_ranges[aux_dim] = ranges[d][aux_dim][p[aux_dim-1]]
#                new_borders.append(tuple(aux_bor))
#                new_ranges.append(tuple(aux_ranges))

#
#
#
#
#    for j in range(len(extremes)):
#        if (len(ranges[j]) + 1) != len(g_range[j]):
#            continue
#        start = 0 if borders[j][0] is None else borders[j][0]+1
#        stop = shape[j] if borders[j][1] is None else borders[j][1]
#        for p in product(*[range(2) for i in range(len(borders)-1)]):
#            new_borders_j, new_ranges_j = [[]]*len(borders), [[]]*len(borders)
#            new_borders_j[j], new_ranges_j[j] = slice(start, stop), g_range[j]
#            for k in range(len(borders)):
#                if k < j:
#                    new_borders_j[k] = borders[k][p[k]]
#                    new_ranges_j[k] = ranges[k][p[k]]
#                elif k > j:
#                    new_borders_j[k] = borders[k][p[k-1]]
#                    new_ranges_j[k] = ranges[k][p[k-1]]
#            if not np.any([e is None for e in new_borders_j]):
#                new_borders.append(tuple(new_borders_j))
#                new_ranges.append(tuple(new_ranges_j))
#
#    return new_borders
#
#
#    new_borders, new_ranges = [], []
#    for p in product(*[range(2) for i in range(len(borders))]):
#        aux = [borders[i][p[i]] for i in range(len(p))]
#        aux_r = [ranges[i][p[i]] for i in range(len(p))]
#        if not np.any([a is None for a in aux]):
#            new_borders.append(tuple(aux))
#            new_ranges.append(tuple(aux_r))


########## 2016-02-27 Retrievers
############################# LWindows Neighbours #############################
###############################################################################
class LWindows2GridRetriever(SpaceRetriever):
    """Class which contains a retriever of L window neighbours for
    2-dimensional grid data.
    """
    _default_ret_val = 1  # {'l': 1}

    def _retrieve_neighs_spec(self, element_i, l, ifdistance=False, kr=0):
        """Retrieve all the neighs in the window of size l."""
        ## Get loc
        loc_i = self._get_loc_i(element_i)
        ## Retrieve logical neighs
        logi = [self.retriever[kr].data[:, 0] < loc_i.ravel()[0]+l/2.,
                self.retriever[kr].data[:, 0] > loc_i.ravel()[0]-l/2.,
                self.retriever[kr].data[:, 1] < loc_i.ravel()[1]+l/2.,
                self.retriever[kr].data[:, 1] > loc_i.ravel()[1]-l/2.]
        aux_logi = np.ones(len(self.retriever[kr].data)).astype(bool)
        for i in range(len(logi)):
            aux_logi = np.logical_and(aux_logi, logi[i])

        ## Compute neighs_info
        if np.any(aux_logi):
            neighs = np.where(aux_logi)[0]
            if ifdistance:
                locs_neighs = self.retriever[kr].data[neighs]
                neighs_info =\
                    self._apply_relative_pos(neighs, loc_i, locs_neighs)
            else:
                neighs_info = neighs, None
        else:
            neighs_info = [], None
        return neighs_info

    def _define_retriever(self, locs, pars_ret=None):
        "Define a kdtree for retrieving neighbours."
        ## If tuple of dimensions
        if type(locs) == tuple:
            shape = locs[:]
            ## Create function for mapping
            shapes = np.cumprod(shape[1:][::-1])[::-1]
            shapes = np.array(list(shapes)[1:] + [1])

            def map2indices(x):
                if x >= np.array(shape):
                    raise IndexError("Indices out of bounds.")
                return np.sum(x*shapes)
            n = np.prod(shape)
            ndim = len(shape)
            locs = np.zeros((n, ndim)).astype(int)
            dims = [xrange(shape[i]) for i in range(ndim)]
            for p in product(*dims):
                i = map2indices(np.array(p))
                locs[i] = np.array(p)
        ## Store in a correct format
        self.retriever.append(DummyRetriever(locs))


##########2016-02-26 Retrievers


#    def set_locs(self, locs, info_ret, info_f):
#        "Set locations for retrieving their neighs."
#        self.data = SpatialElementsCollection(locs)
#        self._autodata = False
#        self._format_retriever_info(info_ret, info_f)


    def _build_excluded_points(self, i_loc, k=0):
        "Build the excluded points from i_loc."
        sh = i_loc.shape
        i_loc = i_loc if len(sh) == 2 else i_loc.reshape(1, sh[0])
        try:
            logi = np.all(self.retriever[k].data == i_loc, axis=1).ravel()
        except:
            logi = np.all(self.retriever[k].data == i_loc)
        assert len(logi) == len(self.retriever[k].data)
#        logi = np.ones(len(self.retriever.data)).astype(bool)
#        for i in range(self.retriever.data.shape[1]):
#            aux_logi = np.array(self.retriever.data)[:, i] == i_loc[:, i]
#            logi = np.logical_and(logi, aux_logi)
        to_exclude_points = np.where(logi)[0]
        return to_exclude_points

############################## NGram Neighbours ###############################
###############################################################################
class NGramRetriever(SpaceRetriever):
    """Class which contains a retriever of Ngram window neighbours for a
    sequential data.
    """
    _default_ret_val = 1

    def _retrieve_neighs_spec(self, element_i, ngram, ifdistance=False, kr=0):
        """Retrieve ngram-1 neighs previously placed in the sequence by
        element_i and the element_i itself."""
        ## Get loc

        if element_i > ngram:
            rel_pos = np.arange(element_i-ngram+1, element_i+1)
            neighs = self.retriever[kr].data[rel_pos]
        else:
            rel_pos = np.arange(0, element_i+1)
            neighs = self.retriever[kr].data[rel_pos]

        if ifdistance:
            neighs_info = neighs, rel_pos
            if self.relative_pos is not None:
                self._apply_relative_pos(neighs_info, element_i, neighs)
        else:
            neighs_info = neighs, None
        return neighs_info

    def _define_retriever(self, elements, pars_ret=None):
        "Define a kdtree for retrieving neighbours."
        self.retriever.append(DummyRetriever(elements))
        ## Iterable elements or the classes has to have a __le__ function
        self._data = sorted(elements)

    ### Overwritting functions
    @property
    def data(self):
        return self.retriever[0].

    @property
    def data_input(self):
        self._data

    @property
    def data_output(self):
        return self.data_input


#class L1DWindowsRetriever(SpaceRetriever):
#    """Class which contains a retriever of Ngram window neighbours for a
#    sequential data.
#    """
#    _default_ret_val = 1
#
#    def _retrieve_neighs_spec(self, element_i, pars_ret, ifdistance=False,
#                              kr=0):
#        """Retrieve ngram-1 neighs previously placed in the sequence by
#        element_i and the element_i itself."""
#        ngram, centered = pars_ret
#        ## Get loc
#        assert(type(element_i) == int)
#        if element_i > ngram:
#            rel_pos = np.arange(element_i-ngram+1, element_i+1)
#        else:
#            rel_pos = np.arange(0, element_i+1)
#
#        neighs = self.retriever[kr].data[rel_pos]
#        if ifdistance:
#            neighs_info = neighs, rel_pos
#            if self.relative_pos is not None:
#                self._apply_relative_pos(neighs_info, element_i, neighs)
#        else:
#            neighs_info = neighs, None
#        return neighs_info
#
#    def _define_retriever(self, elements, pars_ret=None):
#        "Define a kdtree for retrieving neighbours."
#        self.retriever.append(DummyRetriever(elements))



###############################################################################
############################# Element Retrievers ##############################
###############################################################################
class ElementRetriever(Retriever):
    """Retreiver of elements given other elements and only considering the
    information of the non-retrivable elements.
    """
    typeret = 'element'

    def discretize(self, i_locs):
        """Format the index retrieving for the proper index of retrieving of
        the type of retrieving.
        """
        if self._input_map is not None:
            i_locs = self._input_map[i_locs]
        else:
            if self.check_coord(i_locs):
                if type(i_locs) == list:
                    i_locs = -1 * np.ones(len(i_locs))
                else:
                    i_locs = -1
        return i_locs

    ############################ Auxiliar functions ###########################
    ###########################################################################
    def _format_output(self, i_locs, neighs, dists):
        "Format output."
        neighs, dists = self._exclude_auto(i_locs, neighs, dists)
        ## If not auto not do it
        return neighs, dists

    def _check_relative_position(self, relative_position, neighs):
        "Check if the relative position computed is correct."
        if not len(neighs) == len(relative_position):
            raise Exception("Not correct relative position computed.")


##########2016-02-23 Retrievers


    def _check_coord(self, i_locs, k=0, inorout=True):
        """Function to check if the input are coordinates or indices. The input
        is a coordinate when is an array with the same dimension that the pool
        of retrievable locations stored in retriever.data or in self.data.

        Parameters
        ----------
        i_locs: int, list of ints, numpy.ndarray or list of numpy.ndarray
            the locations information.

        Returns
        -------
        checker_coord: boolean
            if there are coordinates True, if there are indices False.

        """
        ## Get individuals
        if type(i_locs) == list:
            check_loc = i_locs[0]
        else:
            check_loc = i_locs
        ## Get checker
        if type(check_loc) in [int, np.int32, np.int64, np.ndarray]:
            if type(check_loc) != np.ndarray:
                checker_coord = False
            else:
                flag = inorout and not self._autoret
                self.locations.shape
                if flag:
                    d_sh = self.data.shape
                else:
                    d_sh = self.retriever[k].data.shape
                if len(check_loc.shape) == len(d_sh):
                    checker_coord = True
                else:
                    raise IndexError("Not correct shape for coordinates.")
        else:
            checker_coord = None
        return checker_coord

    def _retrieve_neighs_reg(self, elem_i, i_disc=0, lim_distance=None,
                             maxif=True, ifdistance=True):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: or for particular use.

        Parameters
        ----------
        elem_i: int or numpy.ndarray
            the elements we want to get its neighbor element.
        i_disc: int
            the discretization we want to apply.
        lim_distance: float
            the bound distance to define neighbourhood.
        maxif: boolean
            if True the bound is the maximum accepted, if False it is the
            minimum.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.
        """
        neighs, dists = self.retriever.retrieve_neighs(elem_i)
        if neighs.any():
            if lim_distance is None:
                logi = np.ones(len(list(dists))).astype(bool)
            else:
                if maxif:
                    logi = dists < lim_distance
                else:
                    logi = dists > lim_distance
            neighs = neighs[logi]
            dists = dists[logi]
        neighs = neighs.ravel()
        return neighs, dists


    def _retrieve_neighs_reg(self, elem_i, i_disc=0):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: or particular use.

        Parameters
        ----------
        elem_i: int or numpy.ndarray
            the element we want to get its neighsbour elements.
        i_disc: int
            the discretization we want to apply.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.
        """
        if type(elem_i) == np.ndarray:
            neighs, dists = np.array(elem_i), np.array([0])
        else:
            neighs = np.array(self.retriever.data[elem_i])
            dists = np.array([0]*neighs.shape[0])
        neighs = neighs.ravel()
        return neighs, dists

    def _retrieve_neighs_reg(self, elem_i, i_disc=0, order=0,
                             exactorlimit=False):
        """Retrieve the elements which are defined by the parameters of the
        inputs and the nature of this object method.
        TODEPRECATE: and suspicious of bad results.

        Parameters
        ----------
        elem_i: int or np.ndarray
            the element we want to get its neighsbour elements.
        order: int
            the order we want to retrieve the object.
        exactorlimit: boolean
            if True we retrieve the neighs in this exact order, if False we
            retrieve the neighs up to this order (included).

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood elements.
        dists: numpy.ndarray
            the distances between elements.

        """
        elem_i = self.retriever.data[elem_i] if type(elem_i) == int else elem_i
        ## 0. Needed variables
        neighs, dists, to_reg = [], [], [elem_i]
        ## Crawling in net variables
        to_reg, to_dists = [elem_i], [self.retriever._inv_null_value]
        reg_explored = []

        ## 1. Crawling in network
        for o in range(order+1):
            neighs_o, dists_o = [], []
            for i in range(len(to_reg)):
                to_reg_i = np.array(to_reg[i])
                neighs_o, dists_o = self.retriever.retrieve_neighs(to_reg_i)
                if self.retriever._distanceorweighs:
                    dists_o += to_dists[i]
                else:
                    dists_o += 1
            ## Add to globals
            n_o = len(neighs_o)
            idx_excl = [i for i in range(n_o) if neighs_o[i]
                        not in reg_explored]
            to_reg = [neighs_o[i] for i in range(n_o) if i not in idx_excl]
            to_dists = [dists_o[i] for i in range(n_o) if i not in idx_excl]
            reg_explored += to_reg
            ## Add to results
            neighs.append(neighs_o)
            dists.append(dists_o)

        ## Exact or limit order formatting output
        if exactorlimit:
            neighs = neighs_o
            dists = dists_o

        neighs, dists = np.hstack(neighs).ravel(), np.hstack(dists)
        return neighs, dists



##########2016-01-14


    def format_output(self, i_loc, neighs, dists):
        """Function which acts as a formatter of the output required by the
        design of the retriever object.

        Parameters
        ----------
        i_loc: int or numpy.ndarray
            the location or the point id.
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood points or regions.
        dists: numpy.ndarray
            the distances between points or regions.

        """
        ## Format output shape
        if not self.regiontype_output:
            n = self.retriever.data.shape[0]
            logi = np.zeros(n).astype(bool)
            dists_i = np.zeros(n)
            for j in range(len(neighs)):
                logi_j = self.locs_r == neighs[j]
                logi = np.logical_or(logi, logi_j)
                dists_i[logi_j] = dists[j]
            neighs = np.where(logi)[0]
            dists = dists_i[logi]
        # Exclude auto point
        neighs, dists = self.exclude_auto(i_loc, neighs, dists)
        # Compute point-point distance
        point_i = self.get_loc_i(i_loc)
        if self.ifcdist:
            dists = cdist(point_i, self.retriever.data[neighs, :])
        return neighs, dists


#    def discretize(self, i_locs, unique=True):
#        """This function transform the input i_locs to discs_i. This discretize
#        function at this level has to deal with different inputs: (i_reg,
#        i_locs, locs_i) and different possibilities: (precomputed, autolocs)
#
#        Parameters
#        ----------
#        i_locs: int, numpy.ndarray, list or int or list of numpy.ndarray
#            the location expressed as regions, id_points or the coordinates of
#            the points.
#
#        Returns
#        -------
#        discs_i: int, list of ints
#            the region ids of the locations specified.
#
#        """
#        if i_locs is None:
#            return None
#        if self.regiontype_input:
#            discs_i = i_locs
#        else:
#            if not self.check_coord(i_locs):
#                if self.precomputed:
#                    if self.autolocs:
#                        discs_i = self.retriever.locs_r[i_locs]
#                    else:
#                        discs_i = self.locs_r[i_locs]
#                else:
#                    if self.autolocs:
#                        locs_i = self.retriever.data[i_locs, :]
#                    else:
#                        locs_i = self.locs[i_locs, :]
#                    discs_i = self.retriever.discretize(locs_i)
#            else:
#                discs_i = self.retriever.discretize(i_locs)
#        return discs_i
#
#    def retrieve_neighs_spec(self, loc_i, info_i, ifdistance=False):
#        """Function of region retrieving.
#
#        Parameters
#        ----------
#        loc_i: int or numpy.ndarray
#            the location or the point id.
#        info_i: optional
#            information of retrieving points.
#        ifdistance: boolean
#            compute distance of the neighbours.
#
#        Returns
#        -------
#        neighs: numpy.ndarray
#            the ids of the neighbourhood regions.
#        dists: numpy.ndarray
#            the distances between regions.
#
#        """
#        ## Discretize location i
#        regs_i = self.discretize(loc_i)
#        ## Retrieve neighbourhood regions
#        neighs, dists = self.retrieve_neigh_r(regs_i, info_i, ifdistance)
#        return neighs, dists




##########2016-01-12

###############################################################################
############################## Region Retrievers ##############################
###############################################################################
class RegionRetriever(Retriever):
    """Retriever class for region-based retrievers.

    TODO:
    -----
    Non-unique discretization.

    """

    typeret = 'region'
    default_ret_val = {}
    locs_r = None

    def __init__(self, locs, discretizors, distance_reg, pars_ret=None,
                 autolocs=None, info_ret=None, flag_auto=True,
                 ifdistance=False, info_f=None, precomputed=True,
                 regiontype_input=True, ifcdist=True, regiontype_output=True):
        "Creation a point retriever class method."
        # Retrieve information
        pars_ret = self.format_pars_ret(pars_ret, precomputed)
        self.retriever = define_Regretriever(locs, discretizors, distance_reg,
                                             **pars_ret)
        self.info_ret = self.default_ret_val if info_ret is None else info_ret
        self.info_f = info_f
        self.ifdistance = ifdistance
        # Location information
        self.autolocs = True if autolocs is None else False
        self.locs = None if autolocs is None else autolocs
        self.locs_r = self.discretize(self.locs) if precomputed else None
        # Input-Output information
        self.flag_auto = flag_auto
        self.regiontype_input = True
        self.regiontype_output = True
        self.ifcdist = True
        # Extra info
        self.precomputed = precomputed

    def discretize(self, i_locs, unique=True):
        """This function transform the input i_locs to discs_i. This discretize
        function at this level has to deal with different inputs: (i_reg,
        i_locs, locs_i) and different possibilities: (precomputed, autolocs)

        Parameters
        ----------
        i_locs: int, numpy.ndarray, list or int or list of numpy.ndarray
            the location expressed as regions, id_points or the coordinates of
            the points.

        Returns
        -------
        discs_i: int, list of ints
            the region ids of the locations specified.

        """
        if i_locs is None:
            return None
        if self.regiontype_input:
            discs_i = i_locs
        else:
            if not self.check_coord(i_locs):
                if self.precomputed:
                    if self.autolocs:
                        discs_i = self.retriever.locs_r[i_locs]
                    else:
                        discs_i = self.locs_r[i_locs]
                else:
                    if self.autolocs:
                        locs_i = self.retriever.data[i_locs, :]
                    else:
                        locs_i = self.locs[i_locs, :]
                    discs_i = self.retriever.discretize(locs_i)
            else:
                discs_i = self.retriever.discretize(i_locs)
        return discs_i

    def retrieve_neighs_spec(self, loc_i, info_i, ifdistance=False):
        """Function of region retrieving.

        Parameters
        ----------
        loc_i: int or numpy.ndarray
            the location or the point id.
        info_i: optional
            information of retrieving points.
        ifdistance: boolean
            compute distance of the neighbours.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        """
        ## Discretize location i
        regs_i = self.discretize(loc_i)
        ## Retrieve neighbourhood regions
        neighs, dists = self.retrieve_neigh_r(regs_i, info_i, ifdistance)
        return neighs, dists

    def retrieve_neigh_r(self, regs_i, info_i={}, ifdistance=False):
        """Retrieve regions neighbourhood.
        """
        info_i = self.retriever.format_info_i_reg(info_i)
        neighs_r, dists_r = self.retriever.retrieve_neigh_reg(regs_i, **info_i)
        dists_r = dists_r if ifdistance else None
        return neighs_r, dists_r

    def format_output(self, i_loc, neighs, dists):
        """Function which acts as a formatter of the output required by the
        design of the retriever object.

        Parameters
        ----------
        i_loc: int or numpy.ndarray
            the location or the point id.
        neighs: numpy.ndarray
            the ids of the neighbourhood regions.
        dists: numpy.ndarray
            the distances between regions.

        Returns
        -------
        neighs: numpy.ndarray
            the ids of the neighbourhood points or regions.
        dists: numpy.ndarray
            the distances between points or regions.

        """
        ## Format output shape
        if not self.regiontype_output:
            n = self.retriever.data.shape[0]
            logi = np.zeros(n).astype(bool)
            dists_i = np.zeros(n)
            for j in range(len(neighs)):
                logi_j = self.locs_r == neighs[j]
                logi = np.logical_or(logi, logi_j)
                dists_i[logi_j] = dists[j]
            neighs = np.where(logi)[0]
            dists = dists_i[logi]
        # Exclude auto point
        neighs, dists = self.exclude_auto(i_loc, neighs, dists)
        # Compute point-point distance
        point_i = self.get_loc_i(i_loc)
        if self.ifcdist:
            dists = cdist(point_i, self.retriever.data[neighs, :])
        return neighs, dists

    def format_pars_ret(self, pars_ret, precomputed):
        pars_ret = {'precomputed': precomputed}
        return pars_ret


def define_Regretriever(locs, discretizor, distance_reg, precomputed=True):
    regretriever = RegionNeighbourhood(locs, discretizor, distance_reg,
                                       precomputed)
    return regretriever




###########2016-01-07

### RegNeigh
#    def retrieve_neigh_i(self, i_loc, info_i={}, ifdistance=False):
#        '''Retrieve the element neighbors of a point.
#
#        Parameters
#        ----------
#        i_loc: int, numpy.ndarray: shape(2,)
#            the location of the point we want to retrieve their neighbors.
#
#        '''
#        ## 0. Proper format
#        info_i = self.format_info_i_reg(info_i, ifdistance)
#        ## 1. Get regions of i_locs
#        disc_i = self.discretize(i_loc)
#        ## 2. Compute region neighbours
#        neigh, dists = self.retrieve_neigh_r(disc_i, info_i, ifdistance)
#        ## 3. Format properly
#        neigh_i, dists_i = self.format_output(i_loc, neigh, dists)
#        return neigh_i, dists


###########2016-01-06


class Neighbourhood:
    """
    Retrieve neighs. It is the main class for retrieve neighbourhood. It could
    retrieve the nearer neighbours in a flat space or the nearer neighbourhoods
    in the pre-discretized space.

    TODO
    ----
    - init
    - precomputed
    - retrieve neighs
    - compute_feats

    """
    aggretrievers = []
    locs = None
    info_ret = None

    precomputed = False

    def __init__(self, retrievers):
        self.retrievers = retrievers

    def set(self, locs, info_ret, auto=True):
        'TODO: Auto, to save memory of locs.'
        self.locs = locs
        self.info_ret = info_ret

    def retrieve_neigh(self, i, typeret):
        point_i = self.locs[i, :].reshape(1, self.locs.shape[1])
        info_i = self.info_ret[i]
        neighs, dists = self.retrievers[typeret].retrieve_neighs(point_i,
                                                                 info_i, True)
        return neighs, dists

    def transform_i(self, i):
        disc_i = discretize(i)
        return disc_i

    def get_neighbourhood(self, i):
        get_region_neighbours(disc_i)
        self.transform_i(i)

    def compute_feats_global(self):
        ## Needs the feature model.
        pass



############ 2015-12-28
class Neighbourhood():
    """
    Retrieve neighs. It is the main class for retrieve neighbourhood. It could
    retrieve the nearer neighbours in a flat space or the nearer neighbourhoods
    in the pre-discretized space.
    """
    aggdiscretizor = None  # discretize space
    aggretriever = None  # aggregation retriever, to retrieve aggregation neigh
    aggfeatures = None  # aggregation features.
    agglocs = None  # locations of the aggregations.

    retriever = None  # main retriever for point2point

    cond_funct = lambda xself, xbool: xbool

    def __init__(self, retriever, typevars, df, reindices, aggretriever,
                 funct=None, discretizor=None):
        self.define_mainretriever(retriever)
        self.define_aggretriever(typevars, df, reindices, aggretriever, funct,
                                 discretizor)

    def define_mainretriever(self, retriever):
        """Main retriever or directed retriever definition. No aggregation
        considered.

        Parameters
        ----------
        retriever: pySpatialTools.retriever class
            the retriever class.

        """
        self.retriever = retriever

    def define_aggretriever(self, typevars, df, reindices, aggretriever,
                            funct=None, discretizor=None):
        """Main function to define an aggretriever. It will save the needed
        information in order to retrieve the neighbours aggregate regions.

        Parameters
        ----------
        typevars: dict
            dictionary with the variables types (loc_vars, feat_vars)
        df: pd.DataFrame
            the data to study.
        reindices: array_like
            the information of permutations.
        aggretriever: retriever object
            the object to retrieve the nearer neighbourhoods.
        funct: function
            function to aggregate 
        discretizor: 

        """
        self.aggdiscretizor, self.aggretriever = discretizor, aggretriever
        if discretizor is not None:
            locs = df[typevars['loc_vars']].as_matrix()
            agg_arr = discretizor.map2id(locs)
            agg_arr = pd.DataFrame(agg_arr, columns=['agg_var'])
            ## Ouputs
            df = pd.concat([df, agg_arr], axis=1)
            typevars['agg_var'] = 'agg_var'
        ## Creation of the aggregator object and aggregation
        agg = Aggregator(typevars)
        agglocs, aggfeatures = agg.retrieve_aggregation(df, reindices, funct)
        ## Instantiation aggretriever
        self.aggretriever = aggretriever(agglocs)
        ## Correction of the agglocs if there is a discretizor
        if discretizor is not None:
            agglocs = discretizor.map2aggloc(agglocs)
        self.aggfeatures, self.agglocs = aggfeatures, agglocs

    def retrieve_neighs(self, point_i, cond_i, info_i):
        """Retrieve the neighs information and the type of retrieving.
        Type of retrieving:
        - aggfeatures: aggregate
        - indices of neighs: neighs_i
        """
        if len(point_i.shape) == 1:
            point_i = point_i.reshape(1, point_i.shape[0])
        typereturn = self.get_type_return(cond_i)
        if typereturn:
            neighbourhood, dist = self.retrieve_neighs_agg(point_i, info_i[1])
        else:
            neighbourhood, dist = self.retrieve_neighs_i(point_i, info_i[0])
        typereturn = 'aggregate' if typereturn else 'individual'
        #neighbourhood = [int(e) for e in neighbourhood]
        return neighbourhood, dist, typereturn

    def retrieve_neighs_agg(self, point_i, info_i):
        "Retrieve the correspondent regions."
        ## Discretizor
        out = self.aggretriever.retrieve_neighs(point_i, info_i)
        return out

    def retrieve_neighs_i(self, point_i, info_i):
        "Retrieve the neighs."
        return self.retriever.retrieve_neighs(point_i, info_i)

    ###########################################################################
    ########################## Condition aggregation ##########################
    ###########################################################################
    def set_aggcondition(self, f):
        "Setting condition function for aggregate data retrieval."
        self.cond_funct = f

    def get_type_return(self, cond_i):
        """Apply condition setted for deciding if neighbourhood of point i is
        retrieved aggregated or not.

        Parameters
        ----------
        cond_i: arbitrary
            information for decide retrieval aggregated or not.

        Returns
        -------
        output: boolean
            retrieve aggregated or not.

        """
        ## TODO: Add the possibility to not be in aggregate and return False
        return self.cond_funct(cond_i)


